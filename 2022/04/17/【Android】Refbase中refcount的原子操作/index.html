<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>【Android】Refbase中refcount的原子操作 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="在读Android 智能指针sp、wp、Refbase的源码时，发现对象引用计数refcount递增的时候使用memory_order_relaxed内存序，但是在递减的时候使用memory_order_release内存序，并且在递减为0时设置内存屏障atomic_thread_fence。强引用计数mstrong递增使用relaxed序好理解，只要保证原子性就可以，但是递减为什么不能用rela">
<meta property="og:type" content="article">
<meta property="og:title" content="【Android】Refbase中refcount的原子操作">
<meta property="og:url" content="http://example.com/2022/04/17/%E3%80%90Android%E3%80%91Refbase%E4%B8%ADrefcount%E7%9A%84%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="在读Android 智能指针sp、wp、Refbase的源码时，发现对象引用计数refcount递增的时候使用memory_order_relaxed内存序，但是在递减的时候使用memory_order_release内存序，并且在递减为0时设置内存屏障atomic_thread_fence。强引用计数mstrong递增使用relaxed序好理解，只要保证原子性就可以，但是递减为什么不能用rela">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2022-04-17T02:54:16.000Z">
<meta property="article:modified_time" content="2022-04-17T15:45:19.955Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.1.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-【Android】Refbase中refcount的原子操作" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/04/17/%E3%80%90Android%E3%80%91Refbase%E4%B8%ADrefcount%E7%9A%84%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/" class="article-date">
  <time class="dt-published" datetime="2022-04-17T02:54:16.000Z" itemprop="datePublished">2022-04-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      【Android】Refbase中refcount的原子操作
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>在读Android 智能指针sp、wp、Refbase的源码时，发现对象引用计数refcount递增的时候使用memory_order_relaxed内存序，但是在递减的时候使用memory_order_release内存序，并且在递减为0时设置内存屏障atomic_thread_fence。强引用计数mstrong递增使用relaxed序好理解，只要保证原子性就可以，但是递减为什么不能用relaxed内存序，差异在哪？</p>
<pre><code>std::atomic&lt;int32_t&gt; mStong;

void RefBase::incStrong(const void* id) const
&#123;
    weakref_impl* const refs = mRefs;
    refs-&gt;incWeak(id);
    ...
    // 递增使用memory_order_relaxed内存序
    const int32_t c = refs-&gt;mStrong.fetch_add(1, std::memory_order_relaxed);
    if (c != INITIAL_STRONG_VALUE)  &#123;
        return;
    &#125;
    ...
&#125;


void RefBase::decStrong(const void* id) const
&#123;
    weakref_impl* const refs = mRefs;
    ...
    // 递减使用memory_order_release内存序
    const int32_t c = refs-&gt;mStrong.fetch_sub(1, std::memory_order_release);
    // c为递减之前的值，为1说明mstrong已经为0了
    if (c == 1) &#123;
        // 设置内存屏障
        std::atomic_thread_fence(std::memory_order_acquire);
        ...
        // delete对象
        delete this;
    &#125;
    ...
&#125;
</code></pre>
<p>在stack overflow中搜到这么个回答，其中有例子代码，但是感觉也没讲到本质，一直在纠结release-acquire ordering的表面意思，没有从指令重排的角度讲，看了半天还没理解：</p>
<pre><code>https://stackoverflow.com/questions/48124031/stdmemory-order-relaxed-atomicity-with-respect-to-the-same-atomic-variable/48148318#48148318
</code></pre>
<p>后面又去看了一些资料，refcount递减使用memory_order_release内存序并且设置内存屏障, 就是为了保证：<br>    在多线程场景下，不管最后哪个线程(将mstrong递减为0的线程)负责delete对象，delete对象一定要发生在其他线程访问对象完成之后</p>
<p>memory_order_release作用是保证当前线程所有读写内存的指令不能重排到release后面，即所有线程访问对象发生在mstrong递减之前</p>
<pre><code>cppreference：A store operation with this memory order performs the release operation: no reads or writes in the current thread can be reordered after this store. All writes in the current thread are visible in other threads that acquire the same atomic variable (see Release-Acquire ordering below) and writes that carry a dependency into the atomic variable become visible in other threads that consume the same atomic (see Release-Consume ordering below). 
</code></pre>
<p>memory_order_acquire作用是保证表示当前线程读写内存的指令不能重排到acquire前面，在mstrong递减为0时，设置acquire的内存屏障，那么在最后将refcount递减为0的线程中，delete对象一定发生在递减为0之后</p>
<pre><code>cppreference：A load operation with this memory order performs the acquire operation on the affected memory location: no reads or writes in the current thread can be reordered before this load. All writes in other threads that release the same atomic variable are visible in the current thread (see Release-Acquire ordering below)
</code></pre>
<p>release和acquire配合起来用就可以达成上面所说的目的</p>
<p>请看下面例子：</p>
<p>有2个线程通过sp智能指针访问同一个对象obj，因为1.2是一定发生在2.2之前(递减为原子操作，肯定是先递减为1，再递减为0)，如果完全按照代码顺序，那么1.1必然发生在2.3之前，不会存在什么问题</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line">A(thread-1)</span><br><span class="line">B[1.1 通过sp指针访问对象obj]</span><br><span class="line">C[1.2 obj引用计数递减为1]</span><br><span class="line">D[线程退出]</span><br><span class="line">E(thread-2)</span><br><span class="line">F[2.1 通过sp指针访问对象obj]</span><br><span class="line">G[2.2 obj引用计数递减为0]</span><br><span class="line">H[2.3 delete obj]</span><br><span class="line">I[线程退出]</span><br><span class="line">A--&gt;B--&gt;C--&gt;D</span><br><span class="line">E--&gt;F--&gt;G--&gt;H--&gt;I</span><br></pre></td></tr></table></figure>

<p>但是ARM架构是弱内存序，cpu执行指令时为了做一些优化，可能会对指令进行重排，但是一定会保证单线程代码执行的正确性。比如将1.1重排到1.2之后，单独看thread-1，是不存在任何问题，因为thread-1递减mstrong之后不需要delete对象，完全不影响正确性。重排之后变成下面这样。虽然1.2还是一定发生在2.2之前，但是已经无法保证1.1发生在2.3之前了。那就有问题了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line">A(thread-1 重排后)</span><br><span class="line">B[1.1 通过sp指针访问对象obj]</span><br><span class="line">C[1.2 obj引用计数递减为1]</span><br><span class="line">D[线程退出]</span><br><span class="line">E(thread-2)</span><br><span class="line">F[2.1 通过sp指针访问对象obj]</span><br><span class="line">G[2.2 obj引用计数递减为0]</span><br><span class="line">H[2.3 delete obj]</span><br><span class="line">I[线程退出]</span><br><span class="line">A--&gt;C--&gt;B--&gt;D</span><br><span class="line">E--&gt;F--&gt;G--&gt;H--&gt;I</span><br></pre></td></tr></table></figure>

<p>再看下cppreference中给的例子，和上面的其实是类似的：</p>
<pre><code>std::atomic&lt;std::string*&gt; ptr;
int data;

void producer()
&#123;
    std::string* p  = new std::string(&quot;Hello&quot;);
    data = 42;
    // 线程1将p赋值给ptr
    // 并且使用release保证data = 42不会重排在store之后
    // 其实重排并不会对线程1正确性产生影响)
    ptr.store(p, std::memory_order_release);
&#125;

void consumer()
&#123;
    std::string* p2;
    // 线程2循环读取ptr，判断ptr是否已经被线程1赋值
    // 并且使用acquire保证assert(data == 42)不会重排在load之后执行
    // 其实重排也不会对线程2正确性产生影响
    while (!(p2 = ptr.load(std::memory_order_acquire)))
    ;
    // 走到这里说明ptr已经被线程1赋值了，那么data肯定已经被线程1赋值为42了
    assert(*p2 == &quot;Hello&quot;); // 必然为真
    assert(data == 42); // 必然为真
&#125;

int main()
&#123;
    std::thread t1(producer);
    std::thread t2(consumer);
    t1.join(); t2.join();
&#125;
</code></pre>
<p>std::atomic使用的内存顺序主要是为了做线程之间的同步。到这里问题基本上搞清楚了，但是还是想看下底层一点的实现，汇编层面上指定内存序是咋实现的。</p>
<pre><code>adrp    x0, data
add     x0, x0, :lo12:data
mov     w1, 42
str     w1, [x0]
adrp    x0, _Z3ptrB5cxx11
add     x0, x0, :lo12:_Z3ptrB5cxx11
mov     w2, 3
ldr     x1, [x29, 48]
bl _ZNSt6atomicIPNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEE5storeES6_St12memory_order
nop


_ZNSt6atomicIPNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEE5storeES6_St12memory_order:
</code></pre>
<p>.LFB2410:<br>        …<br>        add     x29, sp, 0<br>        str     x0, [x29, 40]<br>        str     x1, [x29, 32]<br>        str     w2, [x29, 28]<br>        ldr     x0, [x29, 40]<br>        str     x0, [x29, 64]<br>        ldr     x0, [x29, 32]<br>        str     x0, [x29, 72]<br>        ldr     w0, [x29, 28]<br>        str     w0, [x29, 56]<br>        mov     w1, 65535<br>        ldr     w0, [x29, 56]<br>        bl      _ZStanSt12memory_orderSt23__memory_order_modifier<br>        str     w0, [x29, 60]<br>        ldr     x0, [x29, 64]<br>        ldr     x1, [x29, 72]<br>        stlr    x1, [x0]<br>        nop<br>        ldp     x29, x30, [sp], 80<br>        ret</p>
<pre><code>    .section    .text._ZStanSt12memory_orderSt23__memory_order_modifier,&quot;axG&quot;,@progbits,_ZStanSt12memory_orderSt23__memory_order_modifier,comdat
    .align  2
    .weak   _ZStanSt12memory_orderSt23__memory_order_modifier
    .type   _ZStanSt12memory_orderSt23__memory_order_modifier, %function
</code></pre>
<p>_ZStanSt12memory_orderSt23__memory_order_modifier:<br>.LFB1905:<br>        .cfi_startproc<br>        sub     sp, sp, #16<br>        .cfi_def_cfa_offset 16<br>        str     w0, [sp, 12]<br>        str     w1, [sp, 8]<br>        ldr     w1, [sp, 12]<br>        ldr     w0, [sp, 8]<br>        and     w0, w1, w0<br>        add     sp, sp, 16<br>        .cfi_def_cfa_offset 0<br>        ret<br>        .cfi_endproc<br>.LFE1905:<br>        .size   _ZStanSt12memory_orderSt23__memory_order_modifier, .-_ZStanSt12memory_orderSt23__memory_order_modifier</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/04/17/%E3%80%90Android%E3%80%91Refbase%E4%B8%ADrefcount%E7%9A%84%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/" data-id="cl23gnoez0000k9kr5xpfbc36" data-title="【Android】Refbase中refcount的原子操作" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
    
  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">April 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/04/17/%E3%80%90Android%E3%80%91Refbase%E4%B8%ADrefcount%E7%9A%84%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/">【Android】Refbase中refcount的原子操作</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>