<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.1.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/24/binder%20driver%E5%8D%A0%E7%94%A8%E8%BF%87%E5%A4%9Avmalloc%E7%A9%BA%E9%97%B4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/24/binder%20driver%E5%8D%A0%E7%94%A8%E8%BF%87%E5%A4%9Avmalloc%E7%A9%BA%E9%97%B4/" class="post-title-link" itemprop="url">binder driver占用过多vmalloc空间</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-04-24 22:00:21" itemprop="dateCreated datePublished" datetime="2022-04-24T22:00:21+08:00">2022-04-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-04-26 02:23:13" itemprop="dateModified" datetime="2022-04-26T02:23:13+08:00">2022-04-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Android内核切换到5.10后，看到这么一个修改，说是之前的实现对与32位的安全机器来说，占用了过多的vmalloc空间，打算分析下是怎么修改的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">binder: create userspace-to-binder-buffer copy function</span><br><span class="line">The binder driver uses a vm_area to map the per-process</span><br><span class="line">binder buffer space. For 32-bit android devices, this is</span><br><span class="line">now taking too much vmalloc space. This patch removes</span><br><span class="line">the use of vm_area when copying the transaction data</span><br><span class="line">from the sender to the buffer space. Instead of using</span><br><span class="line">copy_from_user() for multi-page copies, it now uses</span><br><span class="line">binder_alloc_copy_user_to_buffer() which uses kmap()</span><br><span class="line">and kunmap() to map each page, and uses copy_from_user()</span><br><span class="line">for copying to that page.</span><br><span class="line"></span><br><span class="line">Signed-off-by: Todd Kjos &lt;tkjos@google.com&gt;</span><br><span class="line">Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="为什么会占用vmalloc空间"><a href="#为什么会占用vmalloc空间" class="headerlink" title="为什么会占用vmalloc空间"></a>为什么会占用vmalloc空间</h1><p>binder driver为什么会占用vmalloc空间得从binder通信机制中的一次拷贝说起，对于一次拷贝的实现原理我这里写的比较粗，主要是为了说明之前的实现为什么会占用内核虚拟地址空间。详细的实现可以参考下面的这篇博客，写的很好：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://blog.csdn.net/tkwxty/article/details/112325376</span><br></pre></td></tr></table></figure>
<h2 id="用户态进行mmap"><a href="#用户态进行mmap" class="headerlink" title="用户态进行mmap"></a>用户态进行mmap</h2><p>在用户空间，初始化ProcessState时，不仅会open &#x2F;dev&#x2F;binder，还会mmap一段用户空间虚拟地址区域(1M大小)然后进入到binder driver中的binder_mmap函数中</p>
<pre class="mermaid">graph TB
A["// frameworks/native/libs/binder/ProcessState.cpp<br>ProcessState::ProcessState()"]
B["mVMStart = mmap(0, BINDER_VM_SIZE, PROT_READ, MAP_PRIVATE | MAP_NORESERVE, mDriverFD, 0)"]
C["// drivers/android/binder.c<br>binder_mmap(struct file *filp, struct vm_area_struct *vma)"]
D["// drivers/android/binder_alloc.c<br>// 初始化binder_alloc结构体<br>int binder_alloc_mmap_handler(struct binder_alloc *alloc, struct vm_area_struct *vma)"]
A-->B-->C-->D</pre>
<h2 id="binder-driver实现共享物理内存"><a href="#binder-driver实现共享物理内存" class="headerlink" title="binder driver实现共享物理内存"></a>binder driver实现共享物理内存</h2><p>看下linux-4.14上的实现<br><a href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/android?h=linux-4.14.y">https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/android?h=linux-4.14.y</a></p>
<p>binder实现一次拷贝的核心原理就在于共享物理内存，binder driver向用户态传送数据可以直接通过共享物理内存的机制完成，而不需要通过copy_to_user函数</p>
<pre class="mermaid">graph TB
A["user space虚拟地址区域"]
B["kernel space虚拟地址区域"]
C["物理内存"]
A--映射-->C
B--映射-->C
A--固定offset---B</pre>

<pre class="mermaid">graph LR
A["client"]
B["binder_driver"]
C["server"]
A--copy_from_user-->B--共享物理内存-->C</pre>
<p>binder driver要做的事情</p>
<pre><code>1、分配一段相同大小的kernel space虚拟地址区域
2、建立kernel space虚拟地址区域和物理内存的的映射
3、修改用户态进程的页表，建立user space虚拟地址区域和物理内存的映射
</code></pre>
<p>问题就出在”分配一段相同大小的kernel space虚拟地址区域”，每个用户进程使用binder首先都会分配一段1M大小的kernel space虚拟地址区域，而且直到退出才释放。在32位设备上，kernel space虚拟地址区域是要小于1G的，想对来说，binder driver占用的kernel space虚拟地址空间(也就是vmalloc空间)是很多的</p>
<h1 id="修改方案分析"><a href="#修改方案分析" class="headerlink" title="修改方案分析"></a>修改方案分析</h1><h1 id="binder-alloc-代码分析"><a href="#binder-alloc-代码分析" class="headerlink" title="binder_alloc 代码分析"></a>binder_alloc 代码分析</h1><p>binder内存管理还是蛮有意思的，值得好好分析一把</p>
<h2 id="主要结构体"><a href="#主要结构体" class="headerlink" title="主要结构体"></a>主要结构体</h2><p>struct binder_alloc是binder_proc的内存管理结构体，管理binder_buffer和binder_lru_page。binder_transation过程中为了保存用户态传入的数据，会根据数据大小从binder_alloc中找合适的binder_buffer分配出去，同时为该binder_buffer分配实际物理页，物理页使用binder_lru_page描述和管理。初始binder_alloc只有一个binder_buffer，表后面根据分配和释放需求对binder_buffer拆分或者合并。</p>
<pre class="mermaid">classDiagram
class binder_alloc {
    struct vm_area_struct *vma
    struct mm_struct *vma_vm_mm
    void *buffer // 指向vma->start
    size_t buffer_size // vma大小
    struct list_head buffers
    struct rb_root free_buffers
    struct rb_root allocated_buffers
    struct binder_lru_page *pages

    int binder_alloc_mmap_handler(struct binder_alloc *alloc, ...)
    struct binder_buffer *binder_alloc_new_buf(struct binder_alloc *alloc, ...)
    void binder_alloc_free_buf(struct binder_alloc *alloc, ...)
}

class binder_buffer {
    struct list_head entry
    struct rb_node rb_node; 
    unsigned free:1;
    struct binder_transaction *transaction;
    struct binder_node *target_node;
    size_t data_size;
    size_t offsets_size;
    size_t extra_buffers_size;
    void *data;
}

class binder_lru_page {
    struct list_head lru
    struct page *page_ptr
    struct binder_alloc *alloc
}

class binder_proc {
    struct binder_alloc
}

binder_alloc-->binder_buffer
binder_alloc-->binder_lru_page
binder_proc*--binder_alloc</pre>

<h2 id="binder-alloc-mmap-handler-初始化"><a href="#binder-alloc-mmap-handler-初始化" class="headerlink" title="binder_alloc_mmap_handler 初始化"></a>binder_alloc_mmap_handler 初始化</h2><p>1）获取一块和用户态虚拟地址空间相同大小的内核虚拟地址空间，计算2者之间的偏移<br><br>2）创建binder_alloc中的第一个binder_buffer，并将其插入到alloc-&gt;buffers链表和alloc-&gt;free_buffers的红黑树中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">int binder_alloc_mmap_handler(struct binder_alloc *alloc,</span><br><span class="line">			      struct vm_area_struct *vma)</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	struct vm_struct *area;</span><br><span class="line">	struct binder_buffer *buffer;</span><br><span class="line"></span><br><span class="line">    mutex_lock(&amp;binder_alloc_mmap_lock);</span><br><span class="line">    // 获取一块和用户态虚拟地址空间相同大小的内核虚拟地址空间</span><br><span class="line">	area = get_vm_area(vma-&gt;vm_end - vma-&gt;vm_start, VM_ALLOC);</span><br><span class="line">	alloc-&gt;buffer = area-&gt;addr;</span><br><span class="line">    // 计算2者的偏移</span><br><span class="line">	alloc-&gt;user_buffer_offset =</span><br><span class="line">		vma-&gt;vm_start - (uintptr_t)alloc-&gt;buffer;</span><br><span class="line">	mutex_unlock(&amp;binder_alloc_mmap_lock);</span><br><span class="line"></span><br><span class="line">	alloc-&gt;pages = kzalloc(sizeof(alloc-&gt;pages[0]) *</span><br><span class="line">				   ((vma-&gt;vm_end - vma-&gt;vm_start) / PAGE_SIZE),</span><br><span class="line">			       GFP_KERNEL);</span><br><span class="line">	alloc-&gt;buffer_size = vma-&gt;vm_end - vma-&gt;vm_start;</span><br><span class="line"></span><br><span class="line">    // 创建一个binder_buffer，包含分配的整块内核虚拟地址空间</span><br><span class="line">    // 将binder_buffer加入到alloc-&gt;buffers链表中</span><br><span class="line">    // 同时加入到alloc-&gt;free链表中</span><br><span class="line">	buffer = kzalloc(sizeof(*buffer), GFP_KERNEL);</span><br><span class="line">	buffer-&gt;data = alloc-&gt;buffer;</span><br><span class="line">	list_add(&amp;buffer-&gt;entry, &amp;alloc-&gt;buffers);</span><br><span class="line">	buffer-&gt;free = 1;</span><br><span class="line">	binder_insert_free_buffer(alloc, buffer);</span><br><span class="line"></span><br><span class="line">	alloc-&gt;free_async_space = alloc-&gt;buffer_size / 2;</span><br><span class="line">	binder_alloc_set_vma(alloc, vma);</span><br><span class="line">	mmgrab(alloc-&gt;vma_vm_mm);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="binder-alloc-new-buf-分配内存"><a href="#binder-alloc-new-buf-分配内存" class="headerlink" title="binder_alloc_new_buf 分配内存"></a>binder_alloc_new_buf 分配内存</h2><p>1）遍历alloc-&gt;free_buffers红黑树找到适合的binder_buffer分配出去<br><br>2）如果binder_buffer中的内存有剩余，则分割内存，新创建一个binder_buffer来表示剩余的内存。新binder_buffer插入到free_buffer红黑树中；老的binder_buffer从free_buffers红黑树中删除并插入到allocated_buffers红黑树中<br>3）调用binder_update_page_range分配物理页</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">struct binder_buffer *binder_alloc_new_buf_locked(struct binder_alloc *alloc,</span><br><span class="line">						  size_t data_size,</span><br><span class="line">						  size_t offsets_size,</span><br><span class="line">						  size_t extra_buffers_size,</span><br><span class="line">						  int is_async)</span><br><span class="line">&#123;</span><br><span class="line">	struct rb_node *n = alloc-&gt;free_buffers.rb_node;</span><br><span class="line">	struct binder_buffer *buffer;</span><br><span class="line">	size_t buffer_size;</span><br><span class="line">	struct rb_node *best_fit = NULL;</span><br><span class="line">	void *has_page_addr;</span><br><span class="line">	void *end_page_addr;</span><br><span class="line">	size_t size, data_offsets_size;</span><br><span class="line"></span><br><span class="line">	data_offsets_size = ALIGN(data_size, sizeof(void *)) +</span><br><span class="line">		ALIGN(offsets_size, sizeof(void *));</span><br><span class="line">	size = data_offsets_size + ALIGN(extra_buffers_size, sizeof(void *));</span><br><span class="line">	if (is_async &amp;&amp;</span><br><span class="line">	    alloc-&gt;free_async_space &lt; size + sizeof(struct binder_buffer)) &#123;</span><br><span class="line">		return ERR_PTR(-ENOSPC);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/* Pad 0-size buffers so they get assigned unique addresses */</span><br><span class="line">	size = max(size, sizeof(void *));</span><br><span class="line"></span><br><span class="line">	while (n) &#123;</span><br><span class="line">		buffer = rb_entry(n, struct binder_buffer, rb_node);</span><br><span class="line">		buffer_size = binder_alloc_buffer_size(alloc, buffer);</span><br><span class="line"></span><br><span class="line">		if (size &lt; buffer_size) &#123;</span><br><span class="line">			best_fit = n;</span><br><span class="line">			n = n-&gt;rb_left;</span><br><span class="line">		&#125; else if (size &gt; buffer_size)</span><br><span class="line">			n = n-&gt;rb_right;</span><br><span class="line">		else &#123;</span><br><span class="line">			best_fit = n;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if (best_fit == NULL) &#123;</span><br><span class="line">		return ERR_PTR(-ENOSPC);</span><br><span class="line">	&#125;</span><br><span class="line">	if (n == NULL) &#123;</span><br><span class="line">		buffer = rb_entry(best_fit, struct binder_buffer, rb_node);</span><br><span class="line">		buffer_size = binder_alloc_buffer_size(alloc, buffer);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	has_page_addr =</span><br><span class="line">		(void *)(((uintptr_t)buffer-&gt;data + buffer_size) &amp; PAGE_MASK);</span><br><span class="line">	WARN_ON(n &amp;&amp; buffer_size != size);</span><br><span class="line">	end_page_addr =</span><br><span class="line">		(void *)PAGE_ALIGN((uintptr_t)buffer-&gt;data + size);</span><br><span class="line">	if (end_page_addr &gt; has_page_addr)</span><br><span class="line">		end_page_addr = has_page_addr;</span><br><span class="line">	ret = binder_update_page_range(alloc, 1,</span><br><span class="line">	    (void *)PAGE_ALIGN((uintptr_t)buffer-&gt;data), end_page_addr, NULL);</span><br><span class="line">	if (ret)</span><br><span class="line">		return ERR_PTR(ret);</span><br><span class="line"></span><br><span class="line">    // 如果分配size大小的内存后还有剩余</span><br><span class="line">	if (buffer_size != size) &#123;</span><br><span class="line">		struct binder_buffer *new_buffer;</span><br><span class="line">        // 创建一个新的binder_buffer来表示剩余的内存</span><br><span class="line">		new_buffer = kzalloc(sizeof(*buffer), GFP_KERNEL);</span><br><span class="line">		if (!new_buffer) &#123;</span><br><span class="line">			goto err_alloc_buf_struct_failed;</span><br><span class="line">		&#125;</span><br><span class="line">        // 指向剩余内存</span><br><span class="line">		new_buffer-&gt;data = (u8 *)buffer-&gt;data + size;</span><br><span class="line">		// 插入alloc-&gt;buffers链表</span><br><span class="line">        list_add(&amp;new_buffer-&gt;entry, &amp;buffer-&gt;entry);</span><br><span class="line">		new_buffer-&gt;free = 1;</span><br><span class="line">        // 插入到alloc-&gt;free_buffers红黑树</span><br><span class="line">		binder_insert_free_buffer(alloc, new_buffer);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    // 将已经分配出去的binder_buffer从alloc-&gt;free_buffers红黑树中删除</span><br><span class="line">	rb_erase(best_fit, &amp;alloc-&gt;free_buffers);</span><br><span class="line">	buffer-&gt;free = 0;</span><br><span class="line">	buffer-&gt;allow_user_free = 0;</span><br><span class="line">    // 插入到alloc-&gt;allocated_buffers红黑树</span><br><span class="line">	binder_insert_allocated_buffer_locked(alloc, buffer);</span><br><span class="line">	buffer-&gt;data_size = data_size;</span><br><span class="line">	buffer-&gt;offsets_size = offsets_size;</span><br><span class="line">	buffer-&gt;async_transaction = is_async;</span><br><span class="line">	buffer-&gt;extra_buffers_size = extra_buffers_size;</span><br><span class="line">	if (is_async) &#123;</span><br><span class="line">		alloc-&gt;free_async_space -= size + sizeof(struct binder_buffer);</span><br><span class="line">	&#125;</span><br><span class="line">	return buffer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="binder-update-page-range分配物理页"><a href="#binder-update-page-range分配物理页" class="headerlink" title="binder_update_page_range分配物理页"></a>binder_update_page_range分配物理页</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">static int binder_update_page_range(struct binder_alloc *alloc, int allocate,</span><br><span class="line">				    void *start, void *end,</span><br><span class="line">				    struct vm_area_struct *vma)</span><br><span class="line">&#123;</span><br><span class="line">	void *page_addr;</span><br><span class="line">	unsigned long user_page_addr;</span><br><span class="line">	struct binder_lru_page *page;</span><br><span class="line">	struct mm_struct *mm = NULL;</span><br><span class="line">	bool need_mm = false;</span><br><span class="line"></span><br><span class="line">	binder_alloc_debug(BINDER_DEBUG_BUFFER_ALLOC,</span><br><span class="line">		     &quot;%d: %s pages %pK-%pK\n&quot;, alloc-&gt;pid,</span><br><span class="line">		     allocate ? &quot;allocate&quot; : &quot;free&quot;, start, end);</span><br><span class="line"></span><br><span class="line">	if (end &lt;= start)</span><br><span class="line">		return 0;</span><br><span class="line"></span><br><span class="line">	trace_binder_update_page_range(alloc, allocate, start, end);</span><br><span class="line"></span><br><span class="line">	if (allocate == 0)</span><br><span class="line">		goto free_range;</span><br><span class="line"></span><br><span class="line">	for (page_addr = start; page_addr &lt; end; page_addr += PAGE_SIZE) &#123;</span><br><span class="line">		page = &amp;alloc-&gt;pages[(page_addr - alloc-&gt;buffer) / PAGE_SIZE];</span><br><span class="line">		if (!page-&gt;page_ptr) &#123;</span><br><span class="line">			need_mm = true;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (!vma &amp;&amp; need_mm &amp;&amp; mmget_not_zero(alloc-&gt;vma_vm_mm))</span><br><span class="line">		mm = alloc-&gt;vma_vm_mm;</span><br><span class="line"></span><br><span class="line">	if (mm) &#123;</span><br><span class="line">		down_write(&amp;mm-&gt;mmap_sem);</span><br><span class="line">		vma = alloc-&gt;vma;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (!vma &amp;&amp; need_mm) &#123;</span><br><span class="line">		pr_err(&quot;%d: binder_alloc_buf failed to map pages in userspace, no vma\n&quot;,</span><br><span class="line">			alloc-&gt;pid);</span><br><span class="line">		goto err_no_vma;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	for (page_addr = start; page_addr &lt; end; page_addr += PAGE_SIZE) &#123;</span><br><span class="line">		int ret;</span><br><span class="line">		bool on_lru;</span><br><span class="line">		size_t index;</span><br><span class="line"></span><br><span class="line">		index = (page_addr - alloc-&gt;buffer) / PAGE_SIZE;</span><br><span class="line">		page = &amp;alloc-&gt;pages[index];</span><br><span class="line"></span><br><span class="line">		if (page-&gt;page_ptr) &#123;</span><br><span class="line">			trace_binder_alloc_lru_start(alloc, index);</span><br><span class="line"></span><br><span class="line">			on_lru = list_lru_del(&amp;binder_alloc_lru, &amp;page-&gt;lru);</span><br><span class="line">			WARN_ON(!on_lru);</span><br><span class="line"></span><br><span class="line">			trace_binder_alloc_lru_end(alloc, index);</span><br><span class="line">			continue;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (WARN_ON(!vma))</span><br><span class="line">			goto err_page_ptr_cleared;</span><br><span class="line"></span><br><span class="line">		trace_binder_alloc_page_start(alloc, index);</span><br><span class="line">		page-&gt;page_ptr = alloc_page(GFP_KERNEL |</span><br><span class="line">					    __GFP_HIGHMEM |</span><br><span class="line">					    __GFP_ZERO);</span><br><span class="line">		if (!page-&gt;page_ptr) &#123;</span><br><span class="line">			pr_err(&quot;%d: binder_alloc_buf failed for page at %pK\n&quot;,</span><br><span class="line">				alloc-&gt;pid, page_addr);</span><br><span class="line">			goto err_alloc_page_failed;</span><br><span class="line">		&#125;</span><br><span class="line">		page-&gt;alloc = alloc;</span><br><span class="line">		INIT_LIST_HEAD(&amp;page-&gt;lru);</span><br><span class="line"></span><br><span class="line">		ret = map_kernel_range_noflush((unsigned long)page_addr,</span><br><span class="line">					       PAGE_SIZE, PAGE_KERNEL,</span><br><span class="line">					       &amp;page-&gt;page_ptr);</span><br><span class="line">		flush_cache_vmap((unsigned long)page_addr,</span><br><span class="line">				(unsigned long)page_addr + PAGE_SIZE);</span><br><span class="line">		if (ret != 1) &#123;</span><br><span class="line">			pr_err(&quot;%d: binder_alloc_buf failed to map page at %pK in kernel\n&quot;,</span><br><span class="line">			       alloc-&gt;pid, page_addr);</span><br><span class="line">			goto err_map_kernel_failed;</span><br><span class="line">		&#125;</span><br><span class="line">		user_page_addr =</span><br><span class="line">			(uintptr_t)page_addr + alloc-&gt;user_buffer_offset;</span><br><span class="line">		ret = vm_insert_page(vma, user_page_addr, page[0].page_ptr);</span><br><span class="line">		if (ret) &#123;</span><br><span class="line">			pr_err(&quot;%d: binder_alloc_buf failed to map page at %lx in userspace\n&quot;,</span><br><span class="line">			       alloc-&gt;pid, user_page_addr);</span><br><span class="line">			goto err_vm_insert_page_failed;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		trace_binder_alloc_page_end(alloc, index);</span><br><span class="line">		/* vm_insert_page does not seem to increment the refcount */</span><br><span class="line">	&#125;</span><br><span class="line">	if (mm) &#123;</span><br><span class="line">		up_write(&amp;mm-&gt;mmap_sem);</span><br><span class="line">		mmput(mm);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/20/%E3%80%90Android%E3%80%91binder%E4%B8%AD%E7%9A%84selinux%E6%9D%83%E9%99%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/20/%E3%80%90Android%E3%80%91binder%E4%B8%AD%E7%9A%84selinux%E6%9D%83%E9%99%90/" class="post-title-link" itemprop="url">【Android】binder中的selinux权限</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-04-20 22:19:25 / Modified: 22:31:32" itemprop="dateCreated datePublished" datetime="2022-04-20T22:19:25+08:00">2022-04-20</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <pre><code>// security/selinux/include/classmap.h
struct security_class_mapping secclass_map[] = &#123;
    ...
    &#123; &quot;binder&quot;, &#123; &quot;impersonate&quot;, &quot;call&quot;, &quot;set_context_mgr&quot;, &quot;transfer&quot;, NULL &#125; &#125;,
    ...
&#125;
</code></pre>
<h1 id="BINDER-SET-CONTEXT-MGR权限"><a href="#BINDER-SET-CONTEXT-MGR权限" class="headerlink" title="BINDER__SET_CONTEXT_MGR权限"></a>BINDER__SET_CONTEXT_MGR权限</h1><pre><code>// security/selinux/hooks.c
static int selinux_binder_set_context_mgr(const struct cred *mgr)
&#123;
    return avc_has_perm(&amp;selinux_state,
                current_sid(), cred_sid(mgr), SECCLASS_BINDER,
                BINDER__SET_CONTEXT_MGR, NULL);
&#125;
</code></pre>
<h1 id="BINDER-CALL-权限"><a href="#BINDER-CALL-权限" class="headerlink" title="BINDER__CALL 权限"></a>BINDER__CALL 权限</h1><pre><code>// security/selinux/hooks.c
static int selinux_binder_transaction(const struct cred *from,
            	      const struct cred *to)
&#123;
    u32 mysid = current_sid();
    u32 fromsid = cred_sid(from);
    u32 tosid = cred_sid(to);
    int rc;

    if (mysid != fromsid) &#123;
        rc = avc_has_perm(&amp;selinux_state,
                mysid, fromsid, SECCLASS_BINDER,
                BINDER__IMPERSONATE, NULL);
        if (rc)
            return rc;
    &#125;

    return avc_has_perm(&amp;selinux_state, fromsid, tosid,
                SECCLASS_BINDER, BINDER__CALL, NULL);
&#125;
</code></pre>
<h1 id="BINDER-TRANSFER-权限"><a href="#BINDER-TRANSFER-权限" class="headerlink" title="BINDER__TRANSFER 权限"></a>BINDER__TRANSFER 权限</h1><pre><code>// security/selinux/hooks.c
static int selinux_binder_transfer_binder(const struct cred *from,
    				  const struct cred *to)
&#123;
    return avc_has_perm(&amp;selinux_state,
        	    cred_sid(from), cred_sid(to),
                SECCLASS_BINDER, BINDER__TRANSFER,
                NULL);
&#125;
</code></pre>
<h1 id="BINDER-TRANSFER-权限-1"><a href="#BINDER-TRANSFER-权限-1" class="headerlink" title="BINDER__TRANSFER 权限"></a>BINDER__TRANSFER 权限</h1><pre><code>// security/selinux/hooks.c
static int selinux_binder_transfer_file(const struct cred *from,
                const struct cred *to,
                struct file *file)
&#123;
    u32 sid = cred_sid(to);
    struct file_security_struct *fsec = selinux_file(file);
    struct dentry *dentry = file-&gt;f_path.dentry;
    struct inode_security_struct *isec;
    struct common_audit_data ad;
    int rc;

    ad.type = LSM_AUDIT_DATA_PATH;
    ad.u.path = file-&gt;f_path;

    if (sid != fsec-&gt;sid) &#123;
        rc = avc_has_perm(&amp;selinux_state,
                sid, fsec-&gt;sid,
                SECCLASS_FD,
                FD__USE,
                &amp;ad);
        if (rc)
            return rc;
    &#125;

    if (unlikely(IS_PRIVATE(d_backing_inode(dentry))))
        return 0;

    isec = backing_inode_security(dentry);
    return avc_has_perm(&amp;selinux_state,
                sid, isec-&gt;sid, isec-&gt;sclass, file_to_av(file),
                &amp;ad);
&#125;

/* Convert a Linux file to an access vector. */
static inline u32 file_to_av(struct file *file)
&#123;
    u32 av = 0;

    if (file-&gt;f_mode &amp; FMODE_READ)
        av |= FILE__READ;
    if (file-&gt;f_mode &amp; FMODE_WRITE) &#123;
        if (file-&gt;f_flags &amp; O_APPEND)
            av |= FILE__APPEND;
        else
            av |= FILE__WRITE;
    &#125;
    if (!av) &#123;
        /*
        * Special file opened with flags 3 for ioctl-only use.
        */
        av = FILE__IOCTL;
    &#125;

    return av;
&#125;
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/19/%E3%80%90ARM%E3%80%91adrp%E5%92%8Cadr%E6%8C%87%E4%BB%A4%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/19/%E3%80%90ARM%E3%80%91adrp%E5%92%8Cadr%E6%8C%87%E4%BB%A4%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">【ARM】adrp和adr指令详解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-04-19 22:43:14" itemprop="dateCreated datePublished" datetime="2022-04-19T22:43:14+08:00">2022-04-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-04-20 01:10:03" itemprop="dateModified" datetime="2022-04-20T01:10:03+08:00">2022-04-20</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>对adrp和adr这种PC相对寻址的指令一直只知道个大概，比如在取全局变量时经常就会用adrp指令，但是没有深入去了解，最好最近在看armv8的手册，就再梳理下。</p>
<h1 id="ADRP"><a href="#ADRP" class="headerlink" title="ADRP"></a>ADRP</h1><p>先看下armv8用户手册中对adrp指令的描述:</p>
<pre><code>Form PC-relative address to 4KB page adds an immediate value that is shifted left by 12 bits, to the PC value to form a PC-relative address, with the bottom 12 bits masked out, and writes the result to the destination register.

格式：ADRP &lt;Xd&gt;, &lt;label&gt;

&lt;Xd&gt; Is the 64-bit name of the general-purpose destination register, encoded in the &quot;Rd&quot; field.
&lt;label&gt; Is the program label whose 4KB page address is to be calculated. Its offset from the page address of this instruction, in the range +/-4GB, is encoded as &quot;immhi:immlo&quot; times 4096.
</code></pre>
<p>看到上面的这段英文，可能有点绕，没关系，继续往下看：</p>
<pre><code>adrp指令是32位的，指令编码：
31 30  29       23                     5 4       0
--------------------------------------------------
|  |immlo|      |          immhi        |   Rd   |
--------------------------------------------------

指令解码:
// 从低5位中解析目标寄存器的编号，5位编码可以表示32个
integer d = UInt(Rd);
// 从5-23位解析出immhi，从29-30位解析出immhi，加上低12位为0，得到一个32位的立即数
// 把得到的32位立即数扩充到64位，注意是有符号扩充，因为imm可能为负数
bits(64) imm = SignExtend(immhi:immlo:Zeros(12), 64);

伪码：
// 获取PC地址，在armv8上是64位，作为基址base
bits(64) base = PC[];
// 将base低12位置为0，求base所在4K页地址
base&lt;11:0&gt; = Zeros(12);
// base+imm的结果赋给目标寄存器
X[d] = base + imm;
</code></pre>
<p>对上面英文不理解的看到这里应该对adrp指令有点感悟了，所以看指令的描述不如直接看编码和实现，很简单，adrp就是获取当前的PC地址，低12位置0，然后加上一个imm立即数，将最终结果赋给目标寄存器。但是计算imm所用的immhi和immlo是怎么来的呢？adrp的作用又是啥呢？请看这么一段测试代码:</p>
<pre><code>// adrp.c
int a = 0;
int b = 0;

int main()
&#123;
    a = 1;
    return 0;
&#125;
</code></pre>
<p>编译和显示汇编:</p>
<pre><code>aarch64-linux-gnu-gcc adrp.c -o adrp
aarch64-linux-gnu-objdump -D adrp
</code></pre>
<p>main函数汇编如下，可以看到寻址全局变量b的时候就用到adrp指令：</p>
<pre><code>0000000000400570 &lt;main&gt;:
  400570:       b0000080        adrp    x0, 411000 &lt;_GLOBAL_OFFSET_TABLE_+0x28&gt;
  400574:       9100c000        add     x0, x0, #0x2c
  400578:       52800021        mov     w1, #0x1 
  40057c:       b9000001        str     w1, [x0]
  400580:       52800000        mov     w0, #0x0
  400584:       d65f03c0        ret

0000000000411028 &lt;__bss_start&gt;:
  411028:       00000000        .word   0x00000000
000000000041102c &lt;a&gt;:
  41102c:       00000000        .word   0x00000000
0000000000411030 &lt;b&gt;:
    ...
</code></pre>
<p>“adrp x0, 411000” 这条指令的十六进制机器码为b0000080，转成二进制编码就是:    </p>
<pre><code>1100 0000 0000 0000 0000 0000 1000 0000
</code></pre>
<p>根据指令二进制编码进行解码，可以解析出immhi、immlo、Rd</p>
<pre><code>Rd    = 0                    (0-4)     表示目的寄存器是X0
immhi = 0000 0000 0000 100   (5-23)    
immlo = 10                   (29-30)
imm = 0000 0000 0000 0001 0010 0000 0000 0000 = 0x12000
</code></pre>
<p>再根据伪码算最终赋给目标寄存器X0的值是多少</p>
<pre><code>bits(64) base = PC[]   // base = 0x400570
base&lt;11:0&gt; = Zeros(12) // base = 0x400000
X0 = base + imm;       // X0   = 0x412000
</code></pre>
<p>所以”adrp x0, 411000”执行完，X0 &#x3D; 0x412000，继续执行下一条指令”add x0, x0, #0x2c”：</p>
<pre><code>// 0x2c为a地址到所在4k页地址的offset
X0 = X0 + 0x2c = 0x41202c
</code></pre>
<p>诶～ 0x41202c不就是全局变量a的地址吗？就这样对a寻址成功了？是的，这就是adrp的作用！先根据PC+imm进行寻址，获得a所在的4K页地址，再结合add指令，加上offset得到a的最终地址。这就是PC相对寻址，imm就是个相对PC所在4K页地址的offset，可正可负。那反过来adrp指令编码中的immhi和immlo其实是在编译过程中计算出来的：</p>
<pre><code>1) 计算全局变量a所在4K页地址(a地址低12位置0)
2) 计算adrp指令地址所在4K页地址(低12位置0)
3) imm = a所在4K页地址 - adrp指令所在4K页地址
4) 从imm中拆出immlo和immhi，编码到adrp指令中
5) 将a地址到a所在4K页地址的offset编码到下一条add指令中
</code></pre>
<p>adrp寻址原理搞清楚了，接着看下结合add指令，寻址范围有多少：</p>
<pre><code>// 范围共8G，PC地址向前4G，向后4G
2的21次方(immhi和imm共21位) × 4K = -4G ~ +4G
</code></pre>
<h1 id="ADR"><a href="#ADR" class="headerlink" title="ADR"></a>ADR</h1><p>待分析</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/18/%E3%80%90Android%E3%80%91ProcessState%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E4%B8%AD%E7%9A%84%E5%8F%8C%E9%87%8D%E6%A3%80%E6%9F%A5%E9%94%81%E5%AE%9A%E5%86%99%E6%B3%95%E5%B9%B6%E4%B8%8D%E5%AE%89%E5%85%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/18/%E3%80%90Android%E3%80%91ProcessState%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E4%B8%AD%E7%9A%84%E5%8F%8C%E9%87%8D%E6%A3%80%E6%9F%A5%E9%94%81%E5%AE%9A%E5%86%99%E6%B3%95%E5%B9%B6%E4%B8%8D%E5%AE%89%E5%85%A8/" class="post-title-link" itemprop="url">【Android】ProcessState单例模式中的双重检查锁定写法并不安全</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-04-18 22:50:14" itemprop="dateCreated datePublished" datetime="2022-04-18T22:50:14+08:00">2022-04-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-04-19 22:49:56" itemprop="dateModified" datetime="2022-04-19T22:49:56+08:00">2022-04-19</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在看binder源码的时候，看到&#x2F;frameworks&#x2F;native&#x2F;libs&#x2F;binder&#x2F;ProcessState.cpp中有这么一笔修改，说双重检查锁定模式在多线程环境下并不安全：</p>
<pre><code>double checked locking pattern is not safe on SMP
Change-Id: Ie6dd564bdcd45647cb4d62ab259462e3db112576
</code></pre>
<p>修改前的代码本质上是使用双重检查锁定模式的写法，这个写法在单例模式中很常见：</p>
<pre><code>sp&lt;ProcessState&gt; ProcessState::self()
&#123;
    // 第一次检查：如果gprocess不为空，直接返回
    if (gProcess != NULL) &#123;
        return gProcess;
    &#125;
    // gProces为空，可能有多个线程同时执行new ProcessState
    // 所以加锁保证只有一个线程能去new ProcessState
    Mutex::Autolock _l(gProcessMutex);
    // 第二次检查：如果gprocess为空，就new ProcessState
    if (gProcess == NULL) &#123;
        gProcess = new ProcessState(&quot;/dev/binder&quot;);
    &#125;
    return gProcess;
&#125;
</code></pre>
<p>修改后的代码在函数开头就加锁，不管ProcessState对象有没有被创建，每个线程通过这个单例函数获取ProcessState对象时就得获取锁，这样效率肯定会变低，为什么要这么改呢？为什么以前双重检查锁定模式的写法不安全呢？</p>
<pre><code>sp&lt;ProcessState&gt; ProcessState::self()
&#123;
    // 函数开头就加锁，也能保证只有一个线程能去new ProcessState
    Mutex::Autolock _l(gProcessMutex);
    // 只有一次检查
    if (gProcess != NULL) &#123;
        return gProcess;
    &#125;
    gProcess = new ProcessState(&quot;/dev/binder&quot;);
    return gProcess;
&#125;
</code></pre>
<p>创建一个对象并不是原子操作，gProcess &#x3D; new ProcessState(“&#x2F;dev&#x2F;binder”)可以分为3步：</p>
<pre><code>1. 分配ProcessState对象所需内存
2. 初始化对象，比如成员变量fd = open(&quot;/dev/binder&quot;)
3. 将分配的内存地址赋值给gProcess
</code></pre>
<p>因为ARM架构是弱内存序，为了性能优化有时候CPU会做指令重排，正常代码执行顺序是1-&gt;2-&gt;3，但是可能被重排成1-&gt;3-&gt;2。这种重排也不会对单线程运行的结果产生啥影响，所以是有可能发生的。那我们再回过头来看ProcessState::self()函数以前的写法，多个线程同时调用该函数就可能会出现问题：</p>
<pre><code>---------------------------------------------------------------
初始:  gProcess = NULL
---------------------------------------------------------------
线程1: 负责创建对象，但是指令被重排成1-&gt;3-&gt;2，执行完1和3，2还没执行
      gProcess已被赋值却没有完成对象初始化
---------------------------------------------------------------
线程2: 开始获取gProcess，因为gProcess已被线程1赋值，所以获取成功，
      但是线程1还没有完成对象的初始化，线程2去访问gProcess就会出现问题
---------------------------------------------------------------
</code></pre>
<p>所以为了多线程环境下的安全性，只好在函数开头就加锁了，尽管会牺牲一定的效率。Android在开发者网站上也说明了这种场景，链接如下：</p>
<pre><code>https://developer.android.google.cn/training/articles/smp?hl=zh_cn
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/17/%E3%80%90Android%E3%80%91Refbase%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E5%BA%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/17/%E3%80%90Android%E3%80%91Refbase%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E5%BA%8F/" class="post-title-link" itemprop="url">【Android】Refbase对象引用计数操作中的内存序</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-04-17 10:54:16" itemprop="dateCreated datePublished" datetime="2022-04-17T10:54:16+08:00">2022-04-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-04-18 22:46:15" itemprop="dateModified" datetime="2022-04-18T22:46:15+08:00">2022-04-18</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在读Android智能指针sp、wp以及Refbase的源码时，发现对象强引用计数mstrong递增的时候使用memory_order_relaxed内存序，但是在递减的时候使用memory_order_release内存序，并且在递减为0时设置内存屏障atomic_thread_fence(memory_order_acquire)。强引用计数mstrong递增使用relaxed序好理解，只要保证原子性就可以，但是递减为什么不能用relaxed内存序，差异在哪？</p>
<pre><code>std::atomic&lt;int32_t&gt; mStong;

void RefBase::incStrong(const void* id) const
&#123;
    weakref_impl* const refs = mRefs;
    refs-&gt;incWeak(id);
    ...
    // 递增使用memory_order_relaxed内存序
    const int32_t c = refs-&gt;mStrong.fetch_add(1, std::memory_order_relaxed);
    if (c != INITIAL_STRONG_VALUE)  &#123;
        return;
    &#125;
    ...
&#125;
void RefBase::decStrong(const void* id) const
&#123;
    weakref_impl* const refs = mRefs;
    ...
    // 递减使用memory_order_release内存序
    const int32_t c = refs-&gt;mStrong.fetch_sub(1, std::memory_order_release);
    // c为递减之前的值，为1说明mstrong已经为0了
    if (c == 1) &#123;
        // 设置内存屏障
        std::atomic_thread_fence(std::memory_order_acquire);
        ...
        // delete对象
        delete this;
    &#125;
    ...
&#125;
</code></pre>
<p>在stack overflow中搜到这么个回答，其中有例子代码，但是感觉也没讲到本质，一直在纠结release-acquire ordering的表面意思，没有从指令重排的角度讲，看了半天还没理解：</p>
<pre><code>https://stackoverflow.com/questions/48124031/stdmemory-order-relaxed-atomicity-with-respect-to-the-same-atomic-variable/48148318#48148318
</code></pre>
<p>后面又去看了一些资料，mstrong递减使用memory_order_release内存序并且设置内存屏障, 就是为了保证：</p>
<pre><code>在多线程场景下，不管最后哪个线程(将mstrong递减为0的线程)负责delete对象，delete对象一定要发生在其他线程访问对象完成之后
</code></pre>
<p>memory_order_release作用是保证当前线程所有读写内存的指令不能重排到release后面，即所有线程访问对象发生在mstrong递减之前</p>
<pre><code>cppreference中的描述：A store operation with this memory order performs the release operation: no reads or writes in the current thread can be reordered after this store. All writes in the current thread are visible in other threads that acquire the same atomic variable (see Release-Acquire ordering below) and writes that carry a dependency into the atomic variable become visible in other threads that consume the same atomic (see Release-Consume ordering below). 
</code></pre>
<p>memory_order_acquire作用是保证表示当前线程读写内存的指令不能重排到acquire前面，在mstrong递减为0时，设置acquire的内存屏障，那么在最后将refcount递减为0的线程中，delete对象一定发生在递减为0之后</p>
<pre><code>cppreference中的描述：A load operation with this memory order performs the acquire operation on the affected memory location: no reads or writes in the current thread can be reordered before this load. All writes in other threads that release the same atomic variable are visible in the current thread (see Release-Acquire ordering below)
</code></pre>
<p>memory_order_release和memory_order_acquire配合起来用就可以达成上面所说的目的</p>
<p>请看下面例子：</p>
<p>有2个线程通过sp智能指针访问同一个对象obj，因为1.2是一定发生在2.2之前(递减为原子操作，肯定是先递减为1，再递减为0)，如果完全按照代码顺序，那么1.1必然发生在2.3之前，不会存在什么问题</p>
<pre class="mermaid">graph TB
A(thread-1)
B[1.1 通过sp指针访问对象obj]
C[1.2 obj引用计数递减为1]
D[线程退出]
E(thread-2)
F[2.1 通过sp指针访问对象obj]
G[2.2 obj引用计数递减为0]
H[2.3 delete obj]
I[线程退出]
A-->B-->C-->D
E-->F-->G-->H-->I</pre>

<p>但是ARM架构是弱内存序，cpu执行指令时为了做一些优化，可能会对指令进行重排，但是一定会保证单线程代码执行的正确性。比如将1.1重排到1.2之后，单独看thread-1，是不存在任何问题，因为thread-1递减mstrong之后不需要delete对象，完全不影响正确性。重排之后变成下面这样。虽然1.2还是一定发生在2.2之前，但是已经无法保证1.1发生在2.3之前了。那就有问题了</p>
<pre class="mermaid">graph TB
A(thread-1 重排后)
B[1.1 通过sp指针访问对象obj]
C[1.2 obj引用计数递减为1]
D[线程退出]
E(thread-2)
F[2.1 通过sp指针访问对象obj]
G[2.2 obj引用计数递减为0]
H[2.3 delete obj]
I[线程退出]
A-->C-->B-->D
E-->F-->G-->H-->I</pre>

<p>再看下cppreference中给的例子，和上面的其实是类似的：</p>
<pre><code>std::atomic&lt;std::string*&gt; ptr;
int data;

void producer()
&#123;
    std::string* p  = new std::string(&quot;Hello&quot;);
    data = 42;
    // 线程1将p赋值给ptr
    // 并且使用release保证data = 42不会重排在store之后
    // 其实重排并不会对线程1正确性产生影响)
    ptr.store(p, std::memory_order_release);
&#125;
void consumer()
&#123;
    std::string* p2;
    // 线程2循环读取ptr，判断ptr是否已经被线程1赋值
    // 并且使用acquire保证assert(data == 42)不会重排在load之后执行
    // 其实重排也不会对线程2正确性产生影响
    while (!(p2 = ptr.load(std::memory_order_acquire)))
    ;
    // 走到这里说明ptr已经被线程1赋值了，那么data肯定已经被线程1赋值为42了
    assert(*p2 == &quot;Hello&quot;); // 必然为真
    assert(data == 42); // 必然为真
&#125;
int main()
&#123;
    std::thread t1(producer);
    std::thread t2(consumer);
    t1.join(); t2.join();
&#125;
</code></pre>
<p>到这里问题基本上搞清楚了，memory_order_release和memory_order_acquire配合起来可以用来做线程间的同步。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">5</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  













<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

  

</body>
</html>
