<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.1.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/20/%E3%80%90Android%E3%80%91binder%E4%B8%AD%E7%9A%84selinux%E6%9D%83%E9%99%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/20/%E3%80%90Android%E3%80%91binder%E4%B8%AD%E7%9A%84selinux%E6%9D%83%E9%99%90/" class="post-title-link" itemprop="url">【Android】binder中的selinux权限</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-04-20 22:19:25 / Modified: 22:31:32" itemprop="dateCreated datePublished" datetime="2022-04-20T22:19:25+08:00">2022-04-20</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <pre><code>// security/selinux/include/classmap.h
struct security_class_mapping secclass_map[] = &#123;
    ...
    &#123; &quot;binder&quot;, &#123; &quot;impersonate&quot;, &quot;call&quot;, &quot;set_context_mgr&quot;, &quot;transfer&quot;, NULL &#125; &#125;,
    ...
&#125;
</code></pre>
<h1 id="BINDER-SET-CONTEXT-MGR权限"><a href="#BINDER-SET-CONTEXT-MGR权限" class="headerlink" title="BINDER__SET_CONTEXT_MGR权限"></a>BINDER__SET_CONTEXT_MGR权限</h1><pre><code>// security/selinux/hooks.c
static int selinux_binder_set_context_mgr(const struct cred *mgr)
&#123;
    return avc_has_perm(&amp;selinux_state,
                current_sid(), cred_sid(mgr), SECCLASS_BINDER,
                BINDER__SET_CONTEXT_MGR, NULL);
&#125;
</code></pre>
<h1 id="BINDER-CALL-权限"><a href="#BINDER-CALL-权限" class="headerlink" title="BINDER__CALL 权限"></a>BINDER__CALL 权限</h1><pre><code>// security/selinux/hooks.c
static int selinux_binder_transaction(const struct cred *from,
            	      const struct cred *to)
&#123;
    u32 mysid = current_sid();
    u32 fromsid = cred_sid(from);
    u32 tosid = cred_sid(to);
    int rc;

    if (mysid != fromsid) &#123;
        rc = avc_has_perm(&amp;selinux_state,
                mysid, fromsid, SECCLASS_BINDER,
                BINDER__IMPERSONATE, NULL);
        if (rc)
            return rc;
    &#125;

    return avc_has_perm(&amp;selinux_state, fromsid, tosid,
                SECCLASS_BINDER, BINDER__CALL, NULL);
&#125;
</code></pre>
<h1 id="BINDER-TRANSFER-权限"><a href="#BINDER-TRANSFER-权限" class="headerlink" title="BINDER__TRANSFER 权限"></a>BINDER__TRANSFER 权限</h1><pre><code>// security/selinux/hooks.c
static int selinux_binder_transfer_binder(const struct cred *from,
    				  const struct cred *to)
&#123;
    return avc_has_perm(&amp;selinux_state,
        	    cred_sid(from), cred_sid(to),
                SECCLASS_BINDER, BINDER__TRANSFER,
                NULL);
&#125;
</code></pre>
<h1 id="BINDER-TRANSFER-权限-1"><a href="#BINDER-TRANSFER-权限-1" class="headerlink" title="BINDER__TRANSFER 权限"></a>BINDER__TRANSFER 权限</h1><pre><code>// security/selinux/hooks.c
static int selinux_binder_transfer_file(const struct cred *from,
                const struct cred *to,
                struct file *file)
&#123;
    u32 sid = cred_sid(to);
    struct file_security_struct *fsec = selinux_file(file);
    struct dentry *dentry = file-&gt;f_path.dentry;
    struct inode_security_struct *isec;
    struct common_audit_data ad;
    int rc;

    ad.type = LSM_AUDIT_DATA_PATH;
    ad.u.path = file-&gt;f_path;

    if (sid != fsec-&gt;sid) &#123;
        rc = avc_has_perm(&amp;selinux_state,
                sid, fsec-&gt;sid,
                SECCLASS_FD,
                FD__USE,
                &amp;ad);
        if (rc)
            return rc;
    &#125;

    if (unlikely(IS_PRIVATE(d_backing_inode(dentry))))
        return 0;

    isec = backing_inode_security(dentry);
    return avc_has_perm(&amp;selinux_state,
                sid, isec-&gt;sid, isec-&gt;sclass, file_to_av(file),
                &amp;ad);
&#125;

/* Convert a Linux file to an access vector. */
static inline u32 file_to_av(struct file *file)
&#123;
    u32 av = 0;

    if (file-&gt;f_mode &amp; FMODE_READ)
        av |= FILE__READ;
    if (file-&gt;f_mode &amp; FMODE_WRITE) &#123;
        if (file-&gt;f_flags &amp; O_APPEND)
            av |= FILE__APPEND;
        else
            av |= FILE__WRITE;
    &#125;
    if (!av) &#123;
        /*
        * Special file opened with flags 3 for ioctl-only use.
        */
        av = FILE__IOCTL;
    &#125;

    return av;
&#125;
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/19/%E3%80%90ARM%E3%80%91adrp%E5%92%8Cadr%E6%8C%87%E4%BB%A4%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/19/%E3%80%90ARM%E3%80%91adrp%E5%92%8Cadr%E6%8C%87%E4%BB%A4%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">【ARM】adrp和adr指令详解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-04-19 22:43:14" itemprop="dateCreated datePublished" datetime="2022-04-19T22:43:14+08:00">2022-04-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-04-20 01:10:03" itemprop="dateModified" datetime="2022-04-20T01:10:03+08:00">2022-04-20</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>对adrp和adr这种PC相对寻址的指令一直只知道个大概，比如在取全局变量时经常就会用adrp指令，但是没有深入去了解，最好最近在看armv8的手册，就再梳理下。</p>
<h1 id="ADRP"><a href="#ADRP" class="headerlink" title="ADRP"></a>ADRP</h1><p>先看下armv8用户手册中对adrp指令的描述:</p>
<pre><code>Form PC-relative address to 4KB page adds an immediate value that is shifted left by 12 bits, to the PC value to form a PC-relative address, with the bottom 12 bits masked out, and writes the result to the destination register.

格式：ADRP &lt;Xd&gt;, &lt;label&gt;

&lt;Xd&gt; Is the 64-bit name of the general-purpose destination register, encoded in the &quot;Rd&quot; field.
&lt;label&gt; Is the program label whose 4KB page address is to be calculated. Its offset from the page address of this instruction, in the range +/-4GB, is encoded as &quot;immhi:immlo&quot; times 4096.
</code></pre>
<p>看到上面的这段英文，可能有点绕，没关系，继续往下看：</p>
<pre><code>adrp指令是32位的，指令编码：
31 30  29       23                     5 4       0
--------------------------------------------------
|  |immlo|      |          immhi        |   Rd   |
--------------------------------------------------

指令解码:
// 从低5位中解析目标寄存器的编号，5位编码可以表示32个
integer d = UInt(Rd);
// 从5-23位解析出immhi，从29-30位解析出immhi，加上低12位为0，得到一个32位的立即数
// 把得到的32位立即数扩充到64位，注意是有符号扩充，因为imm可能为负数
bits(64) imm = SignExtend(immhi:immlo:Zeros(12), 64);

伪码：
// 获取PC地址，在armv8上是64位，作为基址base
bits(64) base = PC[];
// 将base低12位置为0，求base所在4K页地址
base&lt;11:0&gt; = Zeros(12);
// base+imm的结果赋给目标寄存器
X[d] = base + imm;
</code></pre>
<p>对上面英文不理解的看到这里应该对adrp指令有点感悟了，所以看指令的描述不如直接看编码和实现，很简单，adrp就是获取当前的PC地址，低12位置0，然后加上一个imm立即数，将最终结果赋给目标寄存器。但是计算imm所用的immhi和immlo是怎么来的呢？adrp的作用又是啥呢？请看这么一段测试代码:</p>
<pre><code>// adrp.c
int a = 0;
int b = 0;

int main()
&#123;
    a = 1;
    return 0;
&#125;
</code></pre>
<p>编译和显示汇编:</p>
<pre><code>aarch64-linux-gnu-gcc adrp.c -o adrp
aarch64-linux-gnu-objdump -D adrp
</code></pre>
<p>main函数汇编如下，可以看到寻址全局变量b的时候就用到adrp指令：</p>
<pre><code>0000000000400570 &lt;main&gt;:
  400570:       b0000080        adrp    x0, 411000 &lt;_GLOBAL_OFFSET_TABLE_+0x28&gt;
  400574:       9100c000        add     x0, x0, #0x2c
  400578:       52800021        mov     w1, #0x1 
  40057c:       b9000001        str     w1, [x0]
  400580:       52800000        mov     w0, #0x0
  400584:       d65f03c0        ret

0000000000411028 &lt;__bss_start&gt;:
  411028:       00000000        .word   0x00000000
000000000041102c &lt;a&gt;:
  41102c:       00000000        .word   0x00000000
0000000000411030 &lt;b&gt;:
    ...
</code></pre>
<p>“adrp x0, 411000” 这条指令的十六进制机器码为b0000080，转成二进制编码就是:    </p>
<pre><code>1100 0000 0000 0000 0000 0000 1000 0000
</code></pre>
<p>根据指令二进制编码进行解码，可以解析出immhi、immlo、Rd</p>
<pre><code>Rd    = 0                    (0-4)     表示目的寄存器是X0
immhi = 0000 0000 0000 100   (5-23)    
immlo = 10                   (29-30)
imm = 0000 0000 0000 0001 0010 0000 0000 0000 = 0x12000
</code></pre>
<p>再根据伪码算最终赋给目标寄存器X0的值是多少</p>
<pre><code>bits(64) base = PC[]   // base = 0x400570
base&lt;11:0&gt; = Zeros(12) // base = 0x400000
X0 = base + imm;       // X0   = 0x412000
</code></pre>
<p>所以”adrp x0, 411000”执行完，X0 &#x3D; 0x412000，继续执行下一条指令”add x0, x0, #0x2c”：</p>
<pre><code>// 0x2c为a地址到所在4k页地址的offset
X0 = X0 + 0x2c = 0x41202c
</code></pre>
<p>诶～ 0x41202c不就是全局变量a的地址吗？就这样对a寻址成功了？是的，这就是adrp的作用！先根据PC+imm进行寻址，获得a所在的4K页地址，再结合add指令，加上offset得到a的最终地址。这就是PC相对寻址，imm就是个相对PC所在4K页地址的offset，可正可负。那反过来adrp指令编码中的immhi和immlo其实是在编译过程中计算出来的：</p>
<pre><code>1) 计算全局变量a所在4K页地址(a地址低12位置0)
2) 计算adrp指令地址所在4K页地址(低12位置0)
3) imm = a所在4K页地址 - adrp指令所在4K页地址
4) 从imm中拆出immlo和immhi，编码到adrp指令中
5) 将a地址到a所在4K页地址的offset编码到下一条add指令中
</code></pre>
<p>adrp寻址原理搞清楚了，接着看下结合add指令，寻址范围有多少：</p>
<pre><code>// 范围共8G，PC地址向前4G，向后4G
2的21次方(immhi和imm共21位) × 4K = -4G ~ +4G
</code></pre>
<h1 id="ADR"><a href="#ADR" class="headerlink" title="ADR"></a>ADR</h1><p>待分析</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/18/%E3%80%90Android%E3%80%91ProcessState%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E4%B8%AD%E7%9A%84%E5%8F%8C%E9%87%8D%E6%A3%80%E6%9F%A5%E9%94%81%E5%AE%9A%E5%86%99%E6%B3%95%E5%B9%B6%E4%B8%8D%E5%AE%89%E5%85%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/18/%E3%80%90Android%E3%80%91ProcessState%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E4%B8%AD%E7%9A%84%E5%8F%8C%E9%87%8D%E6%A3%80%E6%9F%A5%E9%94%81%E5%AE%9A%E5%86%99%E6%B3%95%E5%B9%B6%E4%B8%8D%E5%AE%89%E5%85%A8/" class="post-title-link" itemprop="url">【Android】ProcessState单例模式中的双重检查锁定写法并不安全</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-04-18 22:50:14" itemprop="dateCreated datePublished" datetime="2022-04-18T22:50:14+08:00">2022-04-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-04-19 22:49:56" itemprop="dateModified" datetime="2022-04-19T22:49:56+08:00">2022-04-19</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在看binder源码的时候，看到&#x2F;frameworks&#x2F;native&#x2F;libs&#x2F;binder&#x2F;ProcessState.cpp中有这么一笔修改，说双重检查锁定模式在多线程环境下并不安全：</p>
<pre><code>double checked locking pattern is not safe on SMP
Change-Id: Ie6dd564bdcd45647cb4d62ab259462e3db112576
</code></pre>
<p>修改前的代码本质上是使用双重检查锁定模式的写法，这个写法在单例模式中很常见：</p>
<pre><code>sp&lt;ProcessState&gt; ProcessState::self()
&#123;
    // 第一次检查：如果gprocess不为空，直接返回
    if (gProcess != NULL) &#123;
        return gProcess;
    &#125;
    // gProces为空，可能有多个线程同时执行new ProcessState
    // 所以加锁保证只有一个线程能去new ProcessState
    Mutex::Autolock _l(gProcessMutex);
    // 第二次检查：如果gprocess为空，就new ProcessState
    if (gProcess == NULL) &#123;
        gProcess = new ProcessState(&quot;/dev/binder&quot;);
    &#125;
    return gProcess;
&#125;
</code></pre>
<p>修改后的代码在函数开头就加锁，不管ProcessState对象有没有被创建，每个线程通过这个单例函数获取ProcessState对象时就得获取锁，这样效率肯定会变低，为什么要这么改呢？为什么以前双重检查锁定模式的写法不安全呢？</p>
<pre><code>sp&lt;ProcessState&gt; ProcessState::self()
&#123;
    // 函数开头就加锁，也能保证只有一个线程能去new ProcessState
    Mutex::Autolock _l(gProcessMutex);
    // 只有一次检查
    if (gProcess != NULL) &#123;
        return gProcess;
    &#125;
    gProcess = new ProcessState(&quot;/dev/binder&quot;);
    return gProcess;
&#125;
</code></pre>
<p>创建一个对象并不是原子操作，gProcess &#x3D; new ProcessState(“&#x2F;dev&#x2F;binder”)可以分为3步：</p>
<pre><code>1. 分配ProcessState对象所需内存
2. 初始化对象，比如成员变量fd = open(&quot;/dev/binder&quot;)
3. 将分配的内存地址赋值给gProcess
</code></pre>
<p>因为ARM架构是弱内存序，为了性能优化有时候CPU会做指令重排，正常代码执行顺序是1-&gt;2-&gt;3，但是可能被重排成1-&gt;3-&gt;2。这种重排也不会对单线程运行的结果产生啥影响，所以是有可能发生的。那我们再回过头来看ProcessState::self()函数以前的写法，多个线程同时调用该函数就可能会出现问题：</p>
<pre><code>---------------------------------------------------------------
初始:  gProcess = NULL
---------------------------------------------------------------
线程1: 负责创建对象，但是指令被重排成1-&gt;3-&gt;2，执行完1和3，2还没执行
      gProcess已被赋值却没有完成对象初始化
---------------------------------------------------------------
线程2: 开始获取gProcess，因为gProcess已被线程1赋值，所以获取成功，
      但是线程1还没有完成对象的初始化，线程2去访问gProcess就会出现问题
---------------------------------------------------------------
</code></pre>
<p>所以为了多线程环境下的安全性，只好在函数开头就加锁了，尽管会牺牲一定的效率。Android在开发者网站上也说明了这种场景，链接如下：</p>
<pre><code>https://developer.android.google.cn/training/articles/smp?hl=zh_cn
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/17/%E3%80%90Android%E3%80%91Refbase%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E5%BA%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/17/%E3%80%90Android%E3%80%91Refbase%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E5%BA%8F/" class="post-title-link" itemprop="url">【Android】Refbase对象引用计数操作中的内存序</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-04-17 10:54:16" itemprop="dateCreated datePublished" datetime="2022-04-17T10:54:16+08:00">2022-04-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-04-18 22:46:15" itemprop="dateModified" datetime="2022-04-18T22:46:15+08:00">2022-04-18</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在读Android智能指针sp、wp以及Refbase的源码时，发现对象强引用计数mstrong递增的时候使用memory_order_relaxed内存序，但是在递减的时候使用memory_order_release内存序，并且在递减为0时设置内存屏障atomic_thread_fence(memory_order_acquire)。强引用计数mstrong递增使用relaxed序好理解，只要保证原子性就可以，但是递减为什么不能用relaxed内存序，差异在哪？</p>
<pre><code>std::atomic&lt;int32_t&gt; mStong;

void RefBase::incStrong(const void* id) const
&#123;
    weakref_impl* const refs = mRefs;
    refs-&gt;incWeak(id);
    ...
    // 递增使用memory_order_relaxed内存序
    const int32_t c = refs-&gt;mStrong.fetch_add(1, std::memory_order_relaxed);
    if (c != INITIAL_STRONG_VALUE)  &#123;
        return;
    &#125;
    ...
&#125;
void RefBase::decStrong(const void* id) const
&#123;
    weakref_impl* const refs = mRefs;
    ...
    // 递减使用memory_order_release内存序
    const int32_t c = refs-&gt;mStrong.fetch_sub(1, std::memory_order_release);
    // c为递减之前的值，为1说明mstrong已经为0了
    if (c == 1) &#123;
        // 设置内存屏障
        std::atomic_thread_fence(std::memory_order_acquire);
        ...
        // delete对象
        delete this;
    &#125;
    ...
&#125;
</code></pre>
<p>在stack overflow中搜到这么个回答，其中有例子代码，但是感觉也没讲到本质，一直在纠结release-acquire ordering的表面意思，没有从指令重排的角度讲，看了半天还没理解：</p>
<pre><code>https://stackoverflow.com/questions/48124031/stdmemory-order-relaxed-atomicity-with-respect-to-the-same-atomic-variable/48148318#48148318
</code></pre>
<p>后面又去看了一些资料，mstrong递减使用memory_order_release内存序并且设置内存屏障, 就是为了保证：</p>
<pre><code>在多线程场景下，不管最后哪个线程(将mstrong递减为0的线程)负责delete对象，delete对象一定要发生在其他线程访问对象完成之后
</code></pre>
<p>memory_order_release作用是保证当前线程所有读写内存的指令不能重排到release后面，即所有线程访问对象发生在mstrong递减之前</p>
<pre><code>cppreference中的描述：A store operation with this memory order performs the release operation: no reads or writes in the current thread can be reordered after this store. All writes in the current thread are visible in other threads that acquire the same atomic variable (see Release-Acquire ordering below) and writes that carry a dependency into the atomic variable become visible in other threads that consume the same atomic (see Release-Consume ordering below). 
</code></pre>
<p>memory_order_acquire作用是保证表示当前线程读写内存的指令不能重排到acquire前面，在mstrong递减为0时，设置acquire的内存屏障，那么在最后将refcount递减为0的线程中，delete对象一定发生在递减为0之后</p>
<pre><code>cppreference中的描述：A load operation with this memory order performs the acquire operation on the affected memory location: no reads or writes in the current thread can be reordered before this load. All writes in other threads that release the same atomic variable are visible in the current thread (see Release-Acquire ordering below)
</code></pre>
<p>memory_order_release和memory_order_acquire配合起来用就可以达成上面所说的目的</p>
<p>请看下面例子：</p>
<p>有2个线程通过sp智能指针访问同一个对象obj，因为1.2是一定发生在2.2之前(递减为原子操作，肯定是先递减为1，再递减为0)，如果完全按照代码顺序，那么1.1必然发生在2.3之前，不会存在什么问题</p>
<pre class="mermaid">graph TB
A(thread-1)
B[1.1 通过sp指针访问对象obj]
C[1.2 obj引用计数递减为1]
D[线程退出]
E(thread-2)
F[2.1 通过sp指针访问对象obj]
G[2.2 obj引用计数递减为0]
H[2.3 delete obj]
I[线程退出]
A-->B-->C-->D
E-->F-->G-->H-->I</pre>

<p>但是ARM架构是弱内存序，cpu执行指令时为了做一些优化，可能会对指令进行重排，但是一定会保证单线程代码执行的正确性。比如将1.1重排到1.2之后，单独看thread-1，是不存在任何问题，因为thread-1递减mstrong之后不需要delete对象，完全不影响正确性。重排之后变成下面这样。虽然1.2还是一定发生在2.2之前，但是已经无法保证1.1发生在2.3之前了。那就有问题了</p>
<pre class="mermaid">graph TB
A(thread-1 重排后)
B[1.1 通过sp指针访问对象obj]
C[1.2 obj引用计数递减为1]
D[线程退出]
E(thread-2)
F[2.1 通过sp指针访问对象obj]
G[2.2 obj引用计数递减为0]
H[2.3 delete obj]
I[线程退出]
A-->C-->B-->D
E-->F-->G-->H-->I</pre>

<p>再看下cppreference中给的例子，和上面的其实是类似的：</p>
<pre><code>std::atomic&lt;std::string*&gt; ptr;
int data;

void producer()
&#123;
    std::string* p  = new std::string(&quot;Hello&quot;);
    data = 42;
    // 线程1将p赋值给ptr
    // 并且使用release保证data = 42不会重排在store之后
    // 其实重排并不会对线程1正确性产生影响)
    ptr.store(p, std::memory_order_release);
&#125;
void consumer()
&#123;
    std::string* p2;
    // 线程2循环读取ptr，判断ptr是否已经被线程1赋值
    // 并且使用acquire保证assert(data == 42)不会重排在load之后执行
    // 其实重排也不会对线程2正确性产生影响
    while (!(p2 = ptr.load(std::memory_order_acquire)))
    ;
    // 走到这里说明ptr已经被线程1赋值了，那么data肯定已经被线程1赋值为42了
    assert(*p2 == &quot;Hello&quot;); // 必然为真
    assert(data == 42); // 必然为真
&#125;
int main()
&#123;
    std::thread t1(producer);
    std::thread t2(consumer);
    t1.join(); t2.join();
&#125;
</code></pre>
<p>到这里问题基本上搞清楚了，memory_order_release和memory_order_acquire配合起来可以用来做线程间的同步。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">4</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  













<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

  

</body>
</html>
