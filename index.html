<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.1.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/08/%E4%BB%8E%E5%86%85%E6%A0%B80%E5%8F%B7%E7%BA%BF%E7%A8%8B%E5%BC%80%E5%A7%8B%E8%A7%A3%E5%AF%86%E8%BF%9B%E7%A8%8Bselinux%20context%E7%9A%84%E8%AE%BE%E7%BD%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/08/%E4%BB%8E%E5%86%85%E6%A0%B80%E5%8F%B7%E7%BA%BF%E7%A8%8B%E5%BC%80%E5%A7%8B%E8%A7%A3%E5%AF%86%E8%BF%9B%E7%A8%8Bselinux%20context%E7%9A%84%E8%AE%BE%E7%BD%AE/" class="post-title-link" itemprop="url">从内核0号线程开始解密进程selinux context的设置</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-05-08 22:51:33" itemprop="dateCreated datePublished" datetime="2022-05-08T22:51:33+08:00">2022-05-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-05-13 23:10:10" itemprop="dateModified" datetime="2022-05-13T23:10:10+08:00">2022-05-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本文主要分析kernel线程、init进程以及其他进程的selinux context是怎么设置的</p>
<h1 id="从kernel开始说起"><a href="#从kernel开始说起" class="headerlink" title="从kernel开始说起"></a>从kernel开始说起</h1><p>0号线程在start_kernel过程中，在生成1号线程和2号线程之前，就已经调用cred_init_security函数设置了自己的sid：SECINITSID_KERNEL(值为1)。后面生成的kernel线程都会继承这个sid，对应selinux context</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">u:object_r:kernel:s0</span><br></pre></td></tr></table></figure>
<p>context格式为”user:role:type:range”,其中的type，也就是kernel，定义如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># system/sepolicy/public/kernel.te</span><br><span class="line">type kernel, domain, mlstrustedsubject;</span><br></pre></td></tr></table></figure>

<pre class="mermaid">graph BR
H("0号线程<br>(也叫idle线程，使用静态的task_struct和内核栈)")
A["start_kernel()"]
B["security_init()"]
C["selinux_init()"]
D["cred_init_security()<br>设置kernel的selinux context"]
G["rest_init()"]
E["1号线程kernel_init<br>kernel_thread(kernel_init, NULL, CLONE_FS);"]
F["2号线程kthreadd<br>kernel_thread(kthreadd, NULL, CLONE_FS | CLONE_FILES);"]
J["生成其他所有内核线程"]
H-->A-->B-->C-->D-->G
G-->E
G-->F-->J</pre>
<p>cred_init_security函数，把current-&gt;real_cred-&gt;osid&#x2F;sid设置为SECINITSID_KERNEL，也就是把0号线程的osid&#x2F;sid都设置为SECINITSID_KERNEL</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * initialise the security for the init task</span><br><span class="line"> */</span><br><span class="line">static void cred_init_security(void)</span><br><span class="line">&#123;</span><br><span class="line">	struct task_security_struct *tsec;</span><br><span class="line"></span><br><span class="line">	tsec = selinux_cred(unrcu_pointer(current-&gt;real_cred));</span><br><span class="line">	tsec-&gt;osid = tsec-&gt;sid = SECINITSID_KERNEL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre class="mermaid">classDiagram
class task_struct {
    ...
    const struct cred __rcu	*cred
    const struct cred __rcu	*real_cred
    ...
}
class cred {
    ...
    void		*security
    ...
}
class task_security_struct {
    u32 osid;		/* SID prior to last execve */
    u32 sid;		/* current SID */
    u32 exec_sid;		/* exec SID */
    u32 create_sid;		/* fscreate SID */
    u32 keycreate_sid;	/* keycreate SID */
    u32 sockcreate_sid;	/* fscreate SID */
}


task_struct-->cred
cred-->task_security_struct</pre>

<h1 id="init进程"><a href="#init进程" class="headerlink" title="init进程"></a>init进程</h1><h2 id="init进程启动流程"><a href="#init进程启动流程" class="headerlink" title="init进程启动流程"></a>init进程启动流程</h2><p>init进程比较曲折，1号线程kernel_init执行rootfs下的init可执行文件切换到用户态，这个时候init的selinux context还是”u:object_r:kernel:s0”，android把这个阶段叫做first stage，在first stage中加载完selinux策略，execv执行system分区中的init可执行程序，init的selinux context才切换为”u:object_r:init:s0”，android把这个阶段叫做second stage。所以first stage和second stage，虽然都是init进程，但是其实跑的可执行文件不是同一个。</p>
<pre class="mermaid">graph BR
H("1号线程<br>kernel_init")
A["kernel_init()"]
B["run_init_process()"]
C["kernel_execve()<br>执行rootfs下的init可执行文件并切换到用户态"]
D("init进程<br>(u:object_r:kernel:s0)")
E["SetupSelinux()<br>加载selinux策略"]
F["execv(/system/bin/init, ...)<br> 执行system分区中的init可执行文件"]
G("init进程<br>(u:object_r:init:s0)")

H-->A-->B-->C-->D-->E-->F-->G</pre>
<h2 id="init策略配置"><a href="#init策略配置" class="headerlink" title="init策略配置"></a>init策略配置</h2><p>先看下init的selinux策略配置，定义了init和init_exec两种type，配置了type为kenrel的进程执行type为init_exec的可执行文件时自动转换成type init的规则。那么init的context也就从”u:object_r:kernel:s0”转换成了”u:object_r:init:s0”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># sepolicy/public/init.te</span><br><span class="line">type init, domain, mlstrustedsubject;</span><br><span class="line">type init_exec, system_file_type, exec_type, file_type;</span><br><span class="line"></span><br><span class="line"># system/sepolicy/private/kernel.te</span><br><span class="line"># type为kenrel的进程执行type为init_exec的可执行文件时自动转换成init</span><br><span class="line">domain_auto_trans(kernel, init_exec, init)</span><br><span class="line"></span><br><span class="line"># domain_auto_trans宏展开就变成</span><br><span class="line">allow kernel init_exec:file &#123; getattr open read execute map &#125;;</span><br><span class="line">allow kernel init:process transition;</span><br><span class="line">allow init init_exec:file &#123; entrypoint open read execute getattr map &#125;;</span><br><span class="line"># 上面只是赋予kernel做type转换的权限</span><br><span class="line"># 下面这句才是出发自动转换的核心</span><br><span class="line">type_transition kernel init_exec:process init;</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<h2 id="selinux-context转换"><a href="#selinux-context转换" class="headerlink" title="selinux context转换"></a>selinux context转换</h2><p>上面的配置是怎么生效的呢？execv是怎么根据规则完成context转换的呢？execv流程如下，根据函数名就能知道context转换发生在selinux_bprm_creds_for_exec函数中，new_tsec默认继承old_tsec的sid，然后再去判断是否需要做context转换(每一个context都用一个唯一的sid来表示，context转换其实对应的就是sid的转换)</p>
<p>需要做转换的场景有2种：</p>
<p>1）execv之前设置了exec_sid</p>
<p>2）查询到相应的type_transition规则</p>
<p>init就属于第2种，配置了type_transition规则，在selinux_bprm_creds_for_exec函数中做了转换</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type_transition kernel init_exec:process init</span><br></pre></td></tr></table></figure>

<pre class="mermaid">graph LR
A["execv(/system/bin/init, ...)"]
B["sys_execve()"]
C["bprm_execve()"]
D["security_bprm_creds_for_exec()"]
E["exec_binprm()"]
A-->B-->C-->D-->E</pre>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">static int selinux_bprm_creds_for_exec(struct linux_binprm *bprm)</span><br><span class="line">&#123;</span><br><span class="line">	const struct task_security_struct *old_tsec;</span><br><span class="line">	struct task_security_struct *new_tsec;</span><br><span class="line">	struct inode_security_struct *isec;</span><br><span class="line">	struct inode *inode = file_inode(bprm-&gt;file);</span><br><span class="line">	int rc;</span><br><span class="line"></span><br><span class="line">	old_tsec = selinux_cred(current_cred());</span><br><span class="line">	new_tsec = selinux_cred(bprm-&gt;cred);</span><br><span class="line">	isec = inode_security(inode);</span><br><span class="line"></span><br><span class="line">	// 默认继承</span><br><span class="line">	new_tsec-&gt;sid = old_tsec-&gt;sid;</span><br><span class="line">	new_tsec-&gt;osid = old_tsec-&gt;sid;</span><br><span class="line"></span><br><span class="line">	// 判断是否需要sid转换</span><br><span class="line">	if (old_tsec-&gt;exec_sid) &#123;</span><br><span class="line">		// 根据old_tsec-&gt;exec_sid判断是否需要转换</span><br><span class="line">		new_tsec-&gt;sid = old_tsec-&gt;exec_sid;</span><br><span class="line">		new_tsec-&gt;exec_sid = 0;</span><br><span class="line"></span><br><span class="line">		// nnp(no-new-privileges)和nosuid的情况下还需要进行额外的权限检查</span><br><span class="line">		rc = check_nnp_nosuid(bprm, old_tsec, new_tsec);</span><br><span class="line">		if (rc)</span><br><span class="line">			return rc;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		// 查找type_transition规则判断是否需要转换，并返回要转换的目标sid</span><br><span class="line">		// 对应规则type_transition kernel init_exec:process init</span><br><span class="line">		rc = security_transition_sid(&amp;selinux_state, old_tsec-&gt;sid,</span><br><span class="line">					     isec-&gt;sid, SECCLASS_PROCESS, NULL,</span><br><span class="line">					     &amp;new_tsec-&gt;sid);</span><br><span class="line">		if (rc)</span><br><span class="line">			return rc;</span><br><span class="line">		// nnp(no-new-privileges)和nosuid下还需要进行额外的权限检查</span><br><span class="line">		rc = check_nnp_nosuid(bprm, old_tsec, new_tsec);</span><br><span class="line">		if (rc)</span><br><span class="line">			new_tsec-&gt;sid = old_tsec-&gt;sid;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 检查执行可执行文件需要的权限和sid转换需要的权限</span><br><span class="line">	if (new_tsec-&gt;sid == old_tsec-&gt;sid) &#123;</span><br><span class="line">		// 不需要转换，检查FILE__EXECUTE_NO_TRANS权限</span><br><span class="line">		rc = avc_has_perm(&amp;selinux_state,</span><br><span class="line">				  old_tsec-&gt;sid, isec-&gt;sid,</span><br><span class="line">				  SECCLASS_FILE, FILE__EXECUTE_NO_TRANS, &amp;ad);</span><br><span class="line">		if (rc)</span><br><span class="line">			return rc;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		// 需要转换</span><br><span class="line">		// 检查PROCESS__TRANSITION权限</span><br><span class="line">		rc = avc_has_perm(&amp;selinux_state,</span><br><span class="line">				  old_tsec-&gt;sid, new_tsec-&gt;sid,</span><br><span class="line">				  SECCLASS_PROCESS, PROCESS__TRANSITION, &amp;ad);</span><br><span class="line">		if (rc)</span><br><span class="line">			return rc;</span><br><span class="line">		// 检查FILE__ENTRYPOINT权限</span><br><span class="line">		rc = avc_has_perm(&amp;selinux_state,</span><br><span class="line">				  new_tsec-&gt;sid, isec-&gt;sid,</span><br><span class="line">				  SECCLASS_FILE, FILE__ENTRYPOINT, &amp;ad);</span><br><span class="line">		if (rc)</span><br><span class="line">			return rc;</span><br><span class="line">		</span><br><span class="line">		// bprm-&gt;unsafe</span><br><span class="line">		if (bprm-&gt;unsafe &amp; LSM_UNSAFE_SHARE) &#123;</span><br><span class="line">			rc = avc_has_perm(&amp;selinux_state,</span><br><span class="line">					  old_tsec-&gt;sid, new_tsec-&gt;sid,</span><br><span class="line">					  SECCLASS_PROCESS, PROCESS__SHARE,</span><br><span class="line">					  NULL);</span><br><span class="line">			if (rc)</span><br><span class="line">				return -EPERM;</span><br><span class="line">		&#125;</span><br><span class="line">		if (bprm-&gt;unsafe &amp; LSM_UNSAFE_PTRACE) &#123;</span><br><span class="line">			u32 ptsid = ptrace_parent_sid();</span><br><span class="line">			if (ptsid != 0) &#123;</span><br><span class="line">				rc = avc_has_perm(&amp;selinux_state,</span><br><span class="line">						  ptsid, new_tsec-&gt;sid,</span><br><span class="line">						  SECCLASS_PROCESS,</span><br><span class="line">						  PROCESS__PTRACE, NULL);</span><br><span class="line">				if (rc)</span><br><span class="line">					return -EPERM;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		/* Clear any possibly unsafe personality bits on exec: */</span><br><span class="line">		bprm-&gt;per_clear |= PER_CLEAR_ON_SETID;</span><br><span class="line">		</span><br><span class="line">		// 设置bprm-&gt;secureexec</span><br><span class="line">		rc = avc_has_perm(&amp;selinux_state,</span><br><span class="line">				  old_tsec-&gt;sid, new_tsec-&gt;sid,</span><br><span class="line">				  SECCLASS_PROCESS, PROCESS__NOATSECURE,</span><br><span class="line">				  NULL);</span><br><span class="line">		bprm-&gt;secureexec |= !!rc;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>selinux_bprm_creds_for_exec执行完，该做的context转换包括相应的权限检查就都做完了。</p>
<h1 id="其他进程"><a href="#其他进程" class="headerlink" title="其他进程"></a>其他进程</h1><p>其他进程的context设置，核心也是在selinux_bprm_creds_for_exec函数，有下面5种情况：</p>
<p>1）fork 子进程直接继承父进程的context</p>
<p>2）execv + execute_no_trans权限，不做context转换，保持原来的context</p>
<p>3）secexeccon + execv， 本质是设置exec_sid，做context转换，需要secexec和domain_trans权限</p>
<p>以ueventd的context设置为例，直接在rc里面配置”seclabel u:r:ueventd:s0”，init先fork出子进程，子进程的context继承init，为”u:r:ueventd:s0”。子进程首先调用setexeccon(“u:r:ueventd:s0”)，本质上就是写&#x2F;proc&#x2F;self&#x2F;attr&#x2F;exec节点，触发proc_pid_attr_write -&gt; security_setprocattr -&gt; selinux_setprocattr，在selinux_setprocattr函数中修改exec_sid为”u:r:ueventd:s0”对应的sid，然后再execv()，经过sid转换，context就变成了”u:r:ueventd:s0”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// system/core/rootdir/init.rc</span><br><span class="line">service ueventd /system/bin/ueventd</span><br><span class="line">    class core</span><br><span class="line">    critical</span><br><span class="line">    seclabel u:r:ueventd:s0</span><br><span class="line">    shutdown critical</span><br><span class="line"></span><br><span class="line">// system/core/init/service.cpp</span><br><span class="line">void Service::SetProcessAttributes() &#123;</span><br><span class="line">    ...</span><br><span class="line">	if (!seclabel_.empty()) &#123;</span><br><span class="line">		// 设置exec_sid</span><br><span class="line">        if (setexeccon(seclabel_.c_str()) &lt; 0) &#123;</span><br><span class="line">            PLOG(FATAL) &lt;&lt; &quot;cannot setexeccon(&#x27;&quot; &lt;&lt; seclabel_ &lt;&lt; &quot;&#x27;) for &quot; &lt;&lt; name_;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 权限配置 domain_trans和domain_auto_trans宏的区别就是不带type_transition规则</span><br><span class="line">// system/sepolicy/private/init.te</span><br><span class="line">// /system/bin/ueventd是个指向/system/bin/init的软链接，所以这里配置的是init_exec</span><br><span class="line">domain_trans(init, init_exec, ueventd)</span><br><span class="line"></span><br><span class="line">// system/sepolicy/public/init.te</span><br><span class="line">// setexeccon需要的权限，其实就是写exec proc节点所需的权限</span><br><span class="line">allow init self:process &#123; setexec setfscreate setsockcreate &#125;;</span><br></pre></td></tr></table></figure>

<p>4）type_transiton规则 + execv，做context转换，类似上面分析的init，一个domain_auto_trans搞定所有权限</p>
<p>5）进程调用setcon直接修改自己进程的context，需要dyntransition权限和setcurrent权限</p>
<p>setcon本质是去写&#x2F;proc&#x2F;self&#x2F;attr&#x2F;current，和secexeccon一样进入selinux_setprocattr函数中直接修改context。比如zygote，fork子进程跑app，就是直接setcon修改为app相关的context</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// system/sepolicy/private/zygote.te</span><br><span class="line">allow zygote appdomain:process dyntransition;</span><br><span class="line">allow zygote self:process setcurrent;</span><br></pre></td></tr></table></figure>

<p>至于selinux_setprocattr函数倒是不复杂，写&#x2F;proc&#x2F;self&#x2F;attr&#x2F;下面几个节点就会触发，包括exec，current等节点</p>
<p>proc_pid_attr_write -&gt; security_setprocattr -&gt; selinux_setprocattr</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line">static int selinux_setprocattr(const char *name, void *value, size_t size)</span><br><span class="line">&#123;</span><br><span class="line">	struct task_security_struct *tsec;</span><br><span class="line">	struct cred *new;</span><br><span class="line">	u32 mysid = current_sid(), sid = 0, ptsid;</span><br><span class="line">	int error;</span><br><span class="line">	char *str = value;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * Basic control over ability to set these attributes at all.</span><br><span class="line">	 */</span><br><span class="line">	if (!strcmp(name, &quot;exec&quot;))</span><br><span class="line">		error = avc_has_perm(&amp;selinux_state,</span><br><span class="line">				     mysid, mysid, SECCLASS_PROCESS,</span><br><span class="line">				     PROCESS__SETEXEC, NULL);</span><br><span class="line">	else if (!strcmp(name, &quot;fscreate&quot;))</span><br><span class="line">		error = avc_has_perm(&amp;selinux_state,</span><br><span class="line">				     mysid, mysid, SECCLASS_PROCESS,</span><br><span class="line">				     PROCESS__SETFSCREATE, NULL);</span><br><span class="line">	else if (!strcmp(name, &quot;keycreate&quot;))</span><br><span class="line">		error = avc_has_perm(&amp;selinux_state,</span><br><span class="line">				     mysid, mysid, SECCLASS_PROCESS,</span><br><span class="line">				     PROCESS__SETKEYCREATE, NULL);</span><br><span class="line">	else if (!strcmp(name, &quot;sockcreate&quot;))</span><br><span class="line">		error = avc_has_perm(&amp;selinux_state,</span><br><span class="line">				     mysid, mysid, SECCLASS_PROCESS,</span><br><span class="line">				     PROCESS__SETSOCKCREATE, NULL);</span><br><span class="line">	else if (!strcmp(name, &quot;current&quot;))</span><br><span class="line">		error = avc_has_perm(&amp;selinux_state,</span><br><span class="line">				     mysid, mysid, SECCLASS_PROCESS,</span><br><span class="line">				     PROCESS__SETCURRENT, NULL);</span><br><span class="line">	else</span><br><span class="line">		error = -EINVAL;</span><br><span class="line">	if (error)</span><br><span class="line">		return error;</span><br><span class="line"></span><br><span class="line">	/* Obtain a SID for the context, if one was specified. */</span><br><span class="line">	if (size &amp;&amp; str[0] &amp;&amp; str[0] != &#x27;\n&#x27;) &#123;</span><br><span class="line">		if (str[size-1] == &#x27;\n&#x27;) &#123;</span><br><span class="line">			str[size-1] = 0;</span><br><span class="line">			size--;</span><br><span class="line">		&#125;</span><br><span class="line">		error = security_context_to_sid(&amp;selinux_state, value, size,</span><br><span class="line">						&amp;sid, GFP_KERNEL);</span><br><span class="line">		if (error == -EINVAL &amp;&amp; !strcmp(name, &quot;fscreate&quot;)) &#123;</span><br><span class="line">			if (!has_cap_mac_admin(true)) &#123;</span><br><span class="line">				struct audit_buffer *ab;</span><br><span class="line">				size_t audit_size;</span><br><span class="line"></span><br><span class="line">				/* We strip a nul only if it is at the end, otherwise the</span><br><span class="line">				 * context contains a nul and we should audit that */</span><br><span class="line">				if (str[size - 1] == &#x27;\0&#x27;)</span><br><span class="line">					audit_size = size - 1;</span><br><span class="line">				else</span><br><span class="line">					audit_size = size;</span><br><span class="line">				ab = audit_log_start(audit_context(),</span><br><span class="line">						     GFP_ATOMIC,</span><br><span class="line">						     AUDIT_SELINUX_ERR);</span><br><span class="line">				audit_log_format(ab, &quot;op=fscreate invalid_context=&quot;);</span><br><span class="line">				audit_log_n_untrustedstring(ab, value, audit_size);</span><br><span class="line">				audit_log_end(ab);</span><br><span class="line"></span><br><span class="line">				return error;</span><br><span class="line">			&#125;</span><br><span class="line">			error = security_context_to_sid_force(</span><br><span class="line">						      &amp;selinux_state,</span><br><span class="line">						      value, size, &amp;sid);</span><br><span class="line">		&#125;</span><br><span class="line">		if (error)</span><br><span class="line">			return error;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	new = prepare_creds();</span><br><span class="line">	if (!new)</span><br><span class="line">		return -ENOMEM;</span><br><span class="line"></span><br><span class="line">	/* Permission checking based on the specified context is</span><br><span class="line">	   performed during the actual operation (execve,</span><br><span class="line">	   open/mkdir/...), when we know the full context of the</span><br><span class="line">	   operation.  See selinux_bprm_creds_for_exec for the execve</span><br><span class="line">	   checks and may_create for the file creation checks. The</span><br><span class="line">	   operation will then fail if the context is not permitted. */</span><br><span class="line">	tsec = selinux_cred(new);</span><br><span class="line">	if (!strcmp(name, &quot;exec&quot;)) &#123;</span><br><span class="line">		tsec-&gt;exec_sid = sid;</span><br><span class="line">	&#125; else if (!strcmp(name, &quot;fscreate&quot;)) &#123;</span><br><span class="line">		tsec-&gt;create_sid = sid;</span><br><span class="line">	&#125; else if (!strcmp(name, &quot;keycreate&quot;)) &#123;</span><br><span class="line">		if (sid) &#123;</span><br><span class="line">			error = avc_has_perm(&amp;selinux_state, mysid, sid,</span><br><span class="line">					     SECCLASS_KEY, KEY__CREATE, NULL);</span><br><span class="line">			if (error)</span><br><span class="line">				goto abort_change;</span><br><span class="line">		&#125;</span><br><span class="line">		tsec-&gt;keycreate_sid = sid;</span><br><span class="line">	&#125; else if (!strcmp(name, &quot;sockcreate&quot;)) &#123;</span><br><span class="line">		tsec-&gt;sockcreate_sid = sid;</span><br><span class="line">	&#125; else if (!strcmp(name, &quot;current&quot;)) &#123;</span><br><span class="line">		error = -EINVAL;</span><br><span class="line">		if (sid == 0)</span><br><span class="line">			goto abort_change;</span><br><span class="line"></span><br><span class="line">		/* Only allow single threaded processes to change context */</span><br><span class="line">		error = -EPERM;</span><br><span class="line">		if (!current_is_single_threaded()) &#123;</span><br><span class="line">			error = security_bounded_transition(&amp;selinux_state,</span><br><span class="line">							    tsec-&gt;sid, sid);</span><br><span class="line">			if (error)</span><br><span class="line">				goto abort_change;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		/* Check permissions for the transition. */</span><br><span class="line">		error = avc_has_perm(&amp;selinux_state,</span><br><span class="line">				     tsec-&gt;sid, sid, SECCLASS_PROCESS,</span><br><span class="line">				     PROCESS__DYNTRANSITION, NULL);</span><br><span class="line">		if (error)</span><br><span class="line">			goto abort_change;</span><br><span class="line"></span><br><span class="line">		/* Check for ptracing, and update the task SID if ok.</span><br><span class="line">		   Otherwise, leave SID unchanged and fail. */</span><br><span class="line">		ptsid = ptrace_parent_sid();</span><br><span class="line">		if (ptsid != 0) &#123;</span><br><span class="line">			error = avc_has_perm(&amp;selinux_state,</span><br><span class="line">					     ptsid, sid, SECCLASS_PROCESS,</span><br><span class="line">					     PROCESS__PTRACE, NULL);</span><br><span class="line">			if (error)</span><br><span class="line">				goto abort_change;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		tsec-&gt;sid = sid;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		error = -EINVAL;</span><br><span class="line">		goto abort_change;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	commit_creds(new);</span><br><span class="line">	return size;</span><br><span class="line"></span><br><span class="line">abort_change:</span><br><span class="line">	abort_creds(new);</span><br><span class="line">	return error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/24/binder%E4%B8%80%E6%AC%A1%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%9C%A85.10%E5%86%85%E6%A0%B8%E4%B8%8A%E7%9A%84%E5%8F%98%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/24/binder%E4%B8%80%E6%AC%A1%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%9C%A85.10%E5%86%85%E6%A0%B8%E4%B8%8A%E7%9A%84%E5%8F%98%E5%8C%96/" class="post-title-link" itemprop="url">binder一次拷贝的实现在5.10内核上的变化</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-04-24 22:00:21" itemprop="dateCreated datePublished" datetime="2022-04-24T22:00:21+08:00">2022-04-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-04-28 22:05:28" itemprop="dateModified" datetime="2022-04-28T22:05:28+08:00">2022-04-28</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在5.10内核中，看到这么一个修改，说是之前的实现对与32位的安全机器来说，占用了过多的vmalloc空间，不再使用vm_area，那这个修改必然影响到一次拷贝的实现，所以打算对比4.14内核分析下变化的点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">binder: create userspace-to-binder-buffer copy function</span><br><span class="line">The binder driver uses a vm_area to map the per-process</span><br><span class="line">binder buffer space. For 32-bit android devices, this is</span><br><span class="line">now taking too much vmalloc space. This patch removes</span><br><span class="line">the use of vm_area when copying the transaction data</span><br><span class="line">from the sender to the buffer space. Instead of using</span><br><span class="line">copy_from_user() for multi-page copies, it now uses</span><br><span class="line">binder_alloc_copy_user_to_buffer() which uses kmap()</span><br><span class="line">and kunmap() to map each page, and uses copy_from_user()</span><br><span class="line">for copying to that page.</span><br><span class="line"></span><br><span class="line">Signed-off-by: Todd Kjos &lt;tkjos@google.com&gt;</span><br><span class="line">Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="一次拷贝的实现"><a href="#一次拷贝的实现" class="headerlink" title="一次拷贝的实现"></a>一次拷贝的实现</h1><p>这篇博客主要是为了分析一次拷贝的实现从4.14到5.10内核发生了什么变化。关于一次拷贝详细的内容可以参考下面的这篇博客，写的很好：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://blog.csdn.net/tkwxty/article/details/112325376</span><br></pre></td></tr></table></figure>
<h2 id="用户态"><a href="#用户态" class="headerlink" title="用户态"></a>用户态</h2><p>在用户态，初始化ProcessState时，不仅会open &#x2F;dev&#x2F;binder，还会mmap一段user space空间虚拟地址区域(1M大小，后面统一称为vma)然后进入到binder driver中的binder_mmap函数中，流程如下：</p>
<pre class="mermaid">graph TB
A["// frameworks/native/libs/binder/ProcessState.cpp<br>ProcessState::ProcessState()"]
B["mVMStart = mmap(0, BINDER_VM_SIZE, PROT_READ, MAP_PRIVATE | MAP_NORESERVE, mDriverFD, 0)"]
C["// drivers/android/binder.c<br>binder_mmap(struct file *filp, struct vm_area_struct *vma)"]
D["// drivers/android/binder_alloc.c<br>// 初始化binder_alloc结构体<br>int binder_alloc_mmap_handler(struct binder_alloc *alloc, struct vm_area_struct *vma)"]
A-->B-->C-->D</pre>
<h1 id="binder-driver"><a href="#binder-driver" class="headerlink" title="binder driver"></a>binder driver</h1><h2 id="linux-4-14上的实现"><a href="#linux-4-14上的实现" class="headerlink" title="linux-4.14上的实现"></a>linux-4.14上的实现</h2><p><a href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/android?h=linux-4.14.y">https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/android?h=linux-4.14.y</a></p>
<h3 id="主要结构体"><a href="#主要结构体" class="headerlink" title="主要结构体"></a>主要结构体</h3><p>struct binder_alloc是binder_proc的内存管理结构体，管理binder_buffer和binder_lru_page。binder_transation过程中为了保存用户态传入的数据，会根据数据大小从binder_alloc中找合适的binder_buffer分配出去，同时为该binder_buffer分配实际物理页，物理页使用binder_lru_page描述和管理。初始binder_alloc只有一个binder_buffer，表后面根据分配和释放需求对binder_buffer拆分或者合并。</p>
<pre class="mermaid">classDiagram
class binder_alloc {
    struct vm_area_struct *vma
    struct mm_struct *vma_vm_mm
    void *buffer
    size_t buffer_size
    ptrdiff_t user_buffer_offset
    struct list_head buffers
    struct rb_root free_buffers
    struct rb_root allocated_buffers
    struct binder_lru_page *pages
    int binder_alloc_mmap_handler(struct binder_alloc *alloc, ...)
    struct binder_buffer *binder_alloc_new_buf(struct binder_alloc *alloc, ...)
    void binder_alloc_free_buf(struct binder_alloc *alloc, ...)
}

class binder_buffer {
    struct list_head entry
    struct rb_node rb_node
    unsigned free:1
    struct binder_transaction *transaction
    struct binder_node *target_node
    size_t data_size
    size_t offsets_size
    size_t extra_buffers_size
    void *data
}

class binder_lru_page {
    struct list_head lru
    struct page *page_ptr
    struct binder_alloc *alloc
}

class binder_proc {
    struct binder_alloc
}

binder_alloc-->binder_buffer
binder_alloc-->binder_lru_page
binder_proc*--binder_alloc</pre>
<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>binder实现一次拷贝的核心原理就在于共享物理内存，binder driver向用户态传送数据可以直接通过共享物理内存的机制完成，而不需要通过copy_to_user函数。binder driver主要做的事情:</p>
<pre><code>1、分配一段相同大小的kernel space虚拟地址区域(后面统称为vm)并计算vm和vma之间的offset
2、分配物理内存并建立vm和物理内存之间的的映射
3、修改用户态进程的页表，建立vma和物理内存的映射
4、使用copy_from_user将binder transcation data拷贝到vm中的某个地址addr
5、将addr + offset返回给service，service在用户态直接去addr + offset这个地址取binder transcation data就可以了
</code></pre>
<pre class="mermaid">graph TB
    subgraph service
    A[user space虚拟地址区域 vma]
    end
    subgraph binder driver
    B[kernel space虚拟地址区域 vm]
    end
    subgraph client
    D[binder transaction data]
    end
    C[物理内存]

    A--映射-->C
    B--映射-->C
    A--固定offset---B
    D--copy_from_user-->B</pre>
<p>binder driver分配vm是在binder_alloc_mmap_handler函数中做的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int binder_alloc_mmap_handler(struct binder_alloc *alloc,</span><br><span class="line">			      struct vm_area_struct *vma)</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	struct vm_struct *area;</span><br><span class="line">	// 分配vm</span><br><span class="line">	area = get_vm_area(vma-&gt;vm_end - vma-&gt;vm_start, VM_ALLOC);</span><br><span class="line">	if (area == NULL) &#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	alloc-&gt;buffer = area-&gt;addr;</span><br><span class="line">	//计算vma和vm之间的offset</span><br><span class="line">	alloc-&gt;user_buffer_offset =</span><br><span class="line">		vma-&gt;vm_start - (uintptr_t)alloc-&gt;buffer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>binder_driver在binder_transaction函数中将client的binder transaction data使用copy_from_user拷贝到内核中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">static void binder_transaction(struct binder_proc *proc,struct binder_transaction_data *tr, ...)</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	struct binder_transaction *t;</span><br><span class="line">	// 分配binder_buffer(指向内核虚拟地址)</span><br><span class="line">	t-&gt;buffer = binder_alloc_new_buf(&amp;target_proc-&gt;alloc, tr-&gt;data_size, ...);</span><br><span class="line">	// 拷贝用户态数据</span><br><span class="line">	if (copy_from_user(t-&gt;buffer-&gt;data, (const void __user *)(uintptr_t)tr-&gt;data .ptr.buffer, tr-&gt;data_size)) &#123;</span><br><span class="line">		goto err_copy_data_failed;</span><br><span class="line">	&#125;</span><br><span class="line">	if (copy_from_user(offp, (const void __user *)(uintptr_t)tr-&gt;data.ptr.offsets, tr-&gt;offsets_size)) &#123;</span><br><span class="line">		goto err_copy_data_failed;</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个用户进程使用binder首先都会分配这么一段1M大小vm，而且直到退出才释放。在32位设备上，kernel space虚拟地址区域是要小于1G的，相对来说，binder driver占用的kernel space虚拟地址是很多的</p>
<h2 id="linux-5-10上的变化"><a href="#linux-5-10上的变化" class="headerlink" title="linux-5.10上的变化"></a>linux-5.10上的变化</h2><p><a href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/android?h=linux-5.10.y">https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/android?h=linux-5.10.y</a></p>
<pre class="mermaid">graph TB
    subgraph service
    A[user space虚拟地址区域 vma]
    end
    subgraph binder driver
    B["动态kmap区域 (一页大小)"]
    end
    subgraph client
    D[binder_transaction_data]
    end
    C[物理内存]

    A--->C
    B-->C
    D--copy_from_user 循环按页拷贝-->B</pre>

<p>在5.10上，binder driver的变化：<br><br>1）binder_alloc_mmap_handler函数中不再分配一整块(1M大小)的内核虚拟地址区域<br><br>2）binder_buffer中指向的不再是kernel虚拟地址，而直接是user space虚拟地址，binder_buffer和物理内存之间按页匹配，这个很巧妙。binder_alloc中用pages数组记录分配的每个物理页，比如为vma的第一个4K区间分配的物理页的物理地址就记录在pages[0]中，这样就建立了vma各个4K区间和物理页的直接匹配。在函数binder_alloc_get_page中，根据binder_buffer指向的虚拟地址到alloc-&gt;buffer(binder_alloc记录的vma的起始地址)的offset计算出index，就能在pages数组中找到匹配的物理页的物理地址。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">static struct page *binder_alloc_get_page(struct binder_alloc *alloc, struct binder_buffer *buffer, binder_size_t buffer_offset, pgoff_t *pgoffp)</span><br><span class="line">&#123;</span><br><span class="line">	// 计算index</span><br><span class="line">	binder_size_t buffer_space_offset = buffer_offset + (buffer-&gt;user_data - alloc-&gt;buffer);</span><br><span class="line">	pgoff_t pgoff = buffer_space_offset &amp; ~PAGE_MASK;</span><br><span class="line">	size_t index = buffer_space_offset &gt;&gt; PAGE_SHIFT;</span><br><span class="line">	struct binder_lru_page *lru_page;</span><br><span class="line"></span><br><span class="line">	lru_page = &amp;alloc-&gt;pages[index];</span><br><span class="line">	*pgoffp = pgoff;</span><br><span class="line">	// page_ptr是物理地址</span><br><span class="line">	return lru_page-&gt;page_ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><br>3）在binder_transaction函数中使用binder_alloc_copy_user_to_buffer拷贝binder_transaction_data。在binder_alloc_copy_user_to_buffer中，调用binder_alloc_get_page先找到binder_buffer对应的第一个物理页的物理地址，使用kmap映射一页大小的kernel space虚拟地址区域，然后使用copy_from_user拷贝用户态数据(写入物理页)，接着调用kunmap释放映射的这一页kernel space虚拟地址区域，后面继续循环，直到拷贝完所有的用户态数据。这样做拷贝用户数据过程中也就只占用一页的kernel space虚拟地址区域。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">static void binder_transaction(struct binder_proc *proc,struct binder_transaction_data *tr, ...)</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	struct binder_transaction *t;</span><br><span class="line">	// 分配binder_buffer(指向用户虚拟地址)</span><br><span class="line">	t-&gt;buffer = binder_alloc_new_buf(&amp;target_proc-&gt;alloc, tr-&gt;data_size, ...);</span><br><span class="line">	// 拷贝用户态数据</span><br><span class="line">	if (binder_alloc_copy_user_to_buffer(&amp;target_proc-&gt;alloc, t-&gt;buffer, 0, (const void __user *)(uintptr_t)tr-&gt;data.ptr.buffer, tr-&gt;data_size)) &#123;</span><br><span class="line">		goto err_copy_data_failed;</span><br><span class="line">	&#125;</span><br><span class="line">	if (binder_alloc_copy_user_to_buffer(&amp;target_proc-&gt;alloc, t-&gt;buffer, ALIGN(tr-&gt;data_size, sizeof(void *)), (const void __user *)(uintptr_t)tr-&gt;data.ptr.offsets, tr-&gt;offsets_size)) &#123;</span><br><span class="line">		goto err_copy_data_failed;</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">unsigned long binder_alloc_copy_user_to_buffer(struct binder_alloc *alloc, struct binder_buffer *buffer, binder_size_t buffer_offset, const void __user *from, size_t bytes)</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	while (bytes) &#123;</span><br><span class="line">		unsigned long size;</span><br><span class="line">		unsigned long ret;</span><br><span class="line">		struct page *page;</span><br><span class="line">		// buffer-&gt;user_data如果不是页对齐，就需要计算gpoff匹配到物理页的中间</span><br><span class="line">		pgoff_t pgoff;</span><br><span class="line">		void *kptr;</span><br><span class="line"></span><br><span class="line">		page = binder_alloc_get_page(alloc, buffer,</span><br><span class="line">					     buffer_offset, &amp;pgoff);</span><br><span class="line">		size = min_t(size_t, bytes, PAGE_SIZE - pgoff);</span><br><span class="line">		// kmap映射</span><br><span class="line">		kptr = kmap(page) + pgoff;</span><br><span class="line">		ret = copy_from_user(kptr, from, size);</span><br><span class="line">		// kunmap释放</span><br><span class="line">		kunmap(page);</span><br><span class="line">		if (ret)</span><br><span class="line">			return bytes - size + ret;</span><br><span class="line">		bytes -= size;</span><br><span class="line">		from += size;</span><br><span class="line">		buffer_offset += size;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/20/binder%E4%B8%AD%E7%9A%84selinux%E6%9D%83%E9%99%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/20/binder%E4%B8%AD%E7%9A%84selinux%E6%9D%83%E9%99%90/" class="post-title-link" itemprop="url">binder中的selinux权限</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-04-20 22:19:25" itemprop="dateCreated datePublished" datetime="2022-04-20T22:19:25+08:00">2022-04-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-05-08 22:44:00" itemprop="dateModified" datetime="2022-05-08T22:44:00+08:00">2022-05-08</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>基于<a href="http://aospxref.com/android-11.0.0_r21/">http://aospxref.com/android-11.0.0_r21/</a></p>
<h1 id="权限配置"><a href="#权限配置" class="headerlink" title="权限配置"></a>权限配置</h1><h2 id="重要的宏"><a href="#重要的宏" class="headerlink" title="重要的宏"></a>重要的宏</h2><p>binder相关的selinux宏定义在system&#x2F;sepolicy&#x2F;public&#x2F;te_macros中</p>
<h3 id="binder-service"><a href="#binder-service" class="headerlink" title="binder_service"></a>binder_service</h3><p>使用typeattribute把某个service的域(domain)标记成一个binder service域，在定义binder service时使用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># binder_service(domain)</span><br><span class="line"># Mark a domain as being a Binder service domain.</span><br><span class="line"># Used to allow binder IPC to the various system services.</span><br><span class="line">define(`binder_service&#x27;, `</span><br><span class="line">typeattribute $1 binderservicedomain;</span><br></pre></td></tr></table></figure>

<h3 id="binder-use"><a href="#binder-use" class="headerlink" title="binder_use"></a>binder_use</h3><p>servicemanager也是一个特殊的binder服务，binder client和service都需要访问servicemanager，使用binder_use给予client和service访问servicemanager的权限</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># binder_use(domain)</span><br><span class="line"># Allow domain to use Binder IPC.</span><br><span class="line">define(`binder_use&#x27;, `</span><br><span class="line"># Call the servicemanager and transfer references to it.</span><br><span class="line">allow $1 servicemanager:binder &#123; call transfer &#125;;</span><br><span class="line"># Allow servicemanager to send out callbacks</span><br><span class="line">allow servicemanager $1:binder &#123; call transfer &#125;;</span><br><span class="line"># servicemanager performs getpidcon on clients.</span><br><span class="line">allow servicemanager $1:dir search;</span><br><span class="line">allow servicemanager $1:file &#123; read open &#125;;</span><br><span class="line">allow servicemanager $1:process getattr;</span><br><span class="line"># rw access to /dev/binder and /dev/ashmem is presently granted to</span><br><span class="line"># all domains in domain.te</span><br></pre></td></tr></table></figure>
<h3 id="add-service"><a href="#add-service" class="headerlink" title="add_service"></a>add_service</h3><p>给予service进程向servicemanager中注册服务的权限，在定义binder service时使用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># add_service(domain, service)</span><br><span class="line"># Ability for domain to add a service to service_manager</span><br><span class="line"># and find it. It also creates a neverallow preventing</span><br><span class="line"># others from adding it.</span><br><span class="line">define(`add_service&#x27;, `</span><br><span class="line">  allow $1 $2:service_manager &#123; add find &#125;;</span><br><span class="line">  neverallow &#123; domain -$1 &#125; $2:service_manager add;</span><br><span class="line">&#x27;)</span><br></pre></td></tr></table></figure>

<h3 id="binder-call"><a href="#binder-call" class="headerlink" title="binder_call"></a>binder_call</h3><p>给予binder client访问service的权限</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># binder_call(clientdomain, serverdomain)</span><br><span class="line"># Allow clientdomain to perform binder IPC to serverdomain.</span><br><span class="line">define(`binder_call&#x27;, `</span><br><span class="line"># Call the server domain and optionally transfer references to it.</span><br><span class="line">allow $1 $2:binder &#123; call transfer &#125;;</span><br><span class="line"># Allow the serverdomain to transfer references to the client on the reply.</span><br><span class="line">allow $2 $1:binder transfer;</span><br><span class="line"># Receive and use open files from the server.</span><br><span class="line">allow $1 $2:fd use;</span><br><span class="line">&#x27;)</span><br></pre></td></tr></table></figure>
<h2 id="定义一个binder-service"><a href="#定义一个binder-service" class="headerlink" title="定义一个binder service"></a>定义一个binder service</h2><p>以keystore为例，binder_service、binder_user、add_service一套三连就定义完了一个binder service。要注意的是，需要为keystore在servicemanager中注册的服务，定义一个selinux标签：keystore_service，这个标签供servicemanger使用，用作binder client访问注册服务的权限控制</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// system/sepolicy/public/keystore.te</span><br><span class="line">binder_service(keystore)</span><br><span class="line">binder_use(keystore)</span><br><span class="line">add_service(keystore, keystore_service)</span><br><span class="line"></span><br><span class="line">// system/sepolicy/public/service.te</span><br><span class="line">type keystore_service,          service_manager_type;</span><br><span class="line"></span><br><span class="line">// system/sepolicy/private/service_contexts</span><br><span class="line">android.security.keystore              u:object_r:keystore_service:s0</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="配置client访问service的权限"><a href="#配置client访问service的权限" class="headerlink" title="配置client访问service的权限"></a>配置client访问service的权限</h2><p>以wificond访问keystore service为例子，首先binder_use和binder_call二连，再给予wificond在servicemanger中find keystore_service的权限，不然client getService()会失败。上面小节中定义的selinux标签keystore_service的作用就在这里，它不是给binder driver用的，而是给servicemanager用的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// system/sepolicy/public/wificond.te</span><br><span class="line">binder_use(wificond)</span><br><span class="line">binder_call(wificond, keystore)</span><br><span class="line">allow wificond keystore_service:service_manager find;</span><br></pre></td></tr></table></figure>
<p>那么上面所说的这些权限是在哪里检查的呢？往下面看</p>
<h1 id="kernel中的selinux权限检查"><a href="#kernel中的selinux权限检查" class="headerlink" title="kernel中的selinux权限检查"></a>kernel中的selinux权限检查</h1><p>从内核代码中可以看出binder有impersonate、call、set_context_mgr、transfer这几种基础的权限</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// security/selinux/include/classmap.h</span><br><span class="line">struct security_class_mapping secclass_map[] = &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#123; &quot;binder&quot;, &#123; &quot;impersonate&quot;, &quot;call&quot;, &quot;set_context_mgr&quot;, &quot;transfer&quot;, NULL &#125; &#125;,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="set-context-mgr权限"><a href="#set-context-mgr权限" class="headerlink" title="set_context_mgr权限"></a>set_context_mgr权限</h2><p>set_context_mgr是将进程设置为binder管理进程的权限，只有servicemanager才有。对应selinux策略配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">allow servicemanager self:binder set_context_mgr;</span><br></pre></td></tr></table></figure>

<pre class="mermaid">graph TB
A(servicemanager)
B["becomeContextManager()"]
C["binder_ioctl()"]
D["binder_ioctl_set_ctx_mgr()"]
E["security_binder_set_context_mgr()"]
F["selinux_binder_set_context_mgr()"]
A-->B-->C-->D-->E-->F</pre>
<pre><code>// security/selinux/hooks.c
static int selinux_binder_set_context_mgr(const struct cred *mgr)
&#123;
    return avc_has_perm(&amp;selinux_state,
                current_sid(), cred_sid(mgr), SECCLASS_BINDER,
                BINDER__SET_CONTEXT_MGR, NULL);
&#125;
</code></pre>
<h1 id="call和impersonate权限"><a href="#call和impersonate权限" class="headerlink" title="call和impersonate权限"></a>call和impersonate权限</h1><p>call是client对service发起binder transaction需要的权限。对应selinux策略配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">allow wificond servicemanager:binder call;</span><br><span class="line">allow wificond keystore:binder call;</span><br></pre></td></tr></table></figure>
<p>impersonate这个权限比较有意思，发起binder transcation的当前进程sid和最初open &#x2F;dev&#x2F;binder的进程sid不一样，就需要impersonate权限。因为有如下场景，但是目前没有看到android里面有配置这个权限：</p>
<p>1）子进程继承父进程的binder fd，子进程和父进程的sid不一样（selinux域不同），子进程如果想使用继承binder fd发起binder transaction，就需要配置impersonate权限</p>
<p>2）进程使用sendmsg将binder fd发送给其他进程，其他进程和父进程的sid不一样（selinux域不同），其他进程如果想使用收到的binder fd发起binder transaction，就需要配置impersonate权限</p>
<pre class="mermaid">graph TB
A(wificond)
B["transact()"]
C["binder_ioctl()"]
D["binder_thread_write()"]
E["binder_transaction()"]
F["security_binder_transaction()"]
G["selinux_binder_transaction()"]
A-->B-->C-->D-->E-->F-->G</pre>
<pre><code>// security/selinux/hooks.c
static int selinux_binder_transaction(const struct cred *from,
            	      const struct cred *to)
&#123;
    u32 mysid = current_sid();
    u32 fromsid = cred_sid(from);
    u32 tosid = cred_sid(to);
    int rc;

    if (mysid != fromsid) &#123;
        rc = avc_has_perm(&amp;selinux_state,
                mysid, fromsid, SECCLASS_BINDER,
                BINDER__IMPERSONATE, NULL);
        if (rc)
            return rc;
    &#125;

    return avc_has_perm(&amp;selinux_state, fromsid, tosid,
                SECCLASS_BINDER, BINDER__CALL, NULL);
&#125;
</code></pre>
<h1 id="transfer权限"><a href="#transfer权限" class="headerlink" title="transfer权限"></a>transfer权限</h1><p>在binder transaction中传递binder对象引用时会在binder driver中做一次转换，具体参考binder_translate_binder和binder_translate_hander函数。transfer就是client、service、servicemanager之间传递binder对象引用需要的权限，比如：</p>
<p>1）service向servicemanager中注册服务时传递自己的binder引用</p>
<p>2）client向servicemanager获取服务时，servicemanager向client返回service的binder引用，</p>
<p>3）client和service之间传递binder对象引用</p>
<p>对应selinux策略配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">allow wificond servicemanager:binder transfer;</span><br><span class="line">allow keystore servicemanager:binder transfer;</span><br><span class="line">allow servicemanager keystore:binder transfer;</span><br><span class="line">allow servicemanager wificond:binder transfer;</span><br><span class="line">allow wificond keystore:binder transfer；</span><br><span class="line">allow keystore wificond:binder transfer;</span><br></pre></td></tr></table></figure>
<pre class="mermaid">graph TB
E["binder_transaction()"]
F["binder_translate_handle()"]
G["binder_translate_binder()"]
H["security_binder_transfer_binder"]
I["selinux_binder_transfer_binder"]
E-->F-->H
E-->G-->H
H-->I</pre>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// security/selinux/hooks.c</span><br><span class="line">static int selinux_binder_transfer_binder(const struct cred *from,</span><br><span class="line"> 				  const struct cred *to)</span><br><span class="line">&#123;</span><br><span class="line"> return avc_has_perm(&amp;selinux_state,</span><br><span class="line">  	    cred_sid(from), cred_sid(to),</span><br><span class="line">       SECCLASS_BINDER, BINDER__TRANSFER,</span><br><span class="line">       NULL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="fd-use-权限"><a href="#fd-use-权限" class="headerlink" title="fd use 权限"></a>fd use 权限</h1><p>binder通信也支持传递文件描述符fd，client如果要从service接受fd并使用，需要配置fd use权限。对应selinux权限配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">allow wificond keystore:fd use;</span><br></pre></td></tr></table></figure>
<pre class="mermaid">graph TB
E["binder_transaction()"]
F["binder_translate_fd()"]
G["security_binder_transfer_file()"]
H["selinux_binder_transfer_file"]
E-->F-->G-->H</pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">  // security/selinux/hooks.c</span><br><span class="line">  static int selinux_binder_transfer_file(const struct cred *from,</span><br><span class="line">			const struct cred *to,</span><br><span class="line">			struct file *file)</span><br><span class="line">  &#123;</span><br><span class="line">   u32 sid = cred_sid(to);</span><br><span class="line">   struct file_security_struct *fsec = selinux_file(file);</span><br><span class="line">   struct dentry *dentry = file-&gt;f_path.dentry;</span><br><span class="line">   struct inode_security_struct *isec;</span><br><span class="line">   struct common_audit_data ad;</span><br><span class="line">   int rc;</span><br><span class="line"></span><br><span class="line">   ad.type = LSM_AUDIT_DATA_PATH;</span><br><span class="line">   ad.u.path = file-&gt;f_path;</span><br><span class="line">      // fd use权限检查</span><br><span class="line">   if (sid != fsec-&gt;sid) &#123;</span><br><span class="line">    rc = avc_has_perm(&amp;selinux_state,</span><br><span class="line">	        sid, fsec-&gt;sid,</span><br><span class="line">		    SECCLASS_FD,</span><br><span class="line">		    FD__USE,</span><br><span class="line">		    &amp;ad);</span><br><span class="line">    if (rc)</span><br><span class="line">	    return rc;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   if (unlikely(IS_PRIVATE(d_backing_inode(dentry))))</span><br><span class="line">    return 0;</span><br><span class="line">// file_to_av ???</span><br><span class="line">   isec = backing_inode_security(denduiyyingtry);</span><br><span class="line">   return avc_has_perm(&amp;selinux_state,</span><br><span class="line">	        sid, isec-&gt;sid, isec-&gt;sclass, file_to_av(file),</span><br><span class="line">	        &amp;ad);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h1 id="servicemanager中的selinux权限检查"><a href="#servicemanager中的selinux权限检查" class="headerlink" title="servicemanager中的selinux权限检查"></a>servicemanager中的selinux权限检查</h1><p>servicemanager中主要检查：</p>
<p>1）service向servicemanager中注册服务时，servicemangaer检查service是否有注册某个服务的selinux权限，对应</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">allow keystore keystore_service:service_manager add;</span><br></pre></td></tr></table></figure>

<p>2）client向servicemanger中获取服务时，servicemanager检查client是否有获取该服务的selinux权限，对应</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">allow wificpnd keystore_service:service_manager find;</span><br></pre></td></tr></table></figure>

<p>那么servicemanager需要：</p>
<p>1）获取client和service进程的selinux域</p>
<p>2）查询selinux策略库进行selinux权限检查</p>
<h2 id="获取client和service的selinux域"><a href="#获取client和service的selinux域" class="headerlink" title="获取client和service的selinux域"></a>获取client和service的selinux域</h2><p>在binder driver中，如果目标service的txn_security_ctx标志位置为1，则获取client进程的selinux域发送给目标service。在service注册服务、client获取服务时，它们的selinux域会被发送给servicemanager</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// drivers/android/binder.c</span><br><span class="line">// 检查txn_security_ctx标志位</span><br><span class="line">if (target_node &amp;&amp; target_node-&gt;txn_security_ctx) &#123;</span><br><span class="line">	u32 secid;</span><br><span class="line">	size_t added_size;</span><br><span class="line">	// 获取sid</span><br><span class="line">	security_cred_getsecid(proc-&gt;cred, &amp;secid);</span><br><span class="line">	// sid转换成selinux域</span><br><span class="line">	ret = security_secid_to_secctx(secid, &amp;secctx, &amp;secctx_sz);</span><br><span class="line">	if (ret) &#123;</span><br><span class="line">		goto err_get_secctx_failed;</span><br><span class="line">	&#125;</span><br><span class="line">	added_size = ALIGN(secctx_sz, sizeof(u64));</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>servicemanager解析传入的selinux域</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">status_t IPCThreadState::executeCommand(int32_t cmd)</span><br><span class="line">&#123;</span><br><span class="line">    BBinder* obj;</span><br><span class="line">    RefBase::weakref_type* refs;</span><br><span class="line">    status_t result = NO_ERROR;</span><br><span class="line"></span><br><span class="line">    switch ((uint32_t)cmd) &#123;</span><br><span class="line">	...</span><br><span class="line">	case BR_TRANSACTION_SEC_CTX:</span><br><span class="line">    case BR_TRANSACTION:</span><br><span class="line">        &#123;</span><br><span class="line">            binder_transaction_data_secctx tr_secctx;</span><br><span class="line">            binder_transaction_data&amp; tr = tr_secctx.transaction_data;</span><br><span class="line"></span><br><span class="line">            if (cmd == (int) BR_TRANSACTION_SEC_CTX) &#123;</span><br><span class="line">                result = mIn.read(&amp;tr_secctx, sizeof(tr_secctx));</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                result = mIn.read(&amp;tr, sizeof(tr));</span><br><span class="line">                tr_secctx.secctx = 0;</span><br><span class="line">            &#125;</span><br><span class="line">			...</span><br><span class="line">			// 获取对方的pid</span><br><span class="line">			mCallingPid = tr.sender_pid;</span><br><span class="line">			// 获取对方的selinux域</span><br><span class="line">            mCallingSid = reinterpret_cast&lt;const char*&gt;(tr_secctx.secctx);</span><br><span class="line">            mCallingUid = tr.sender_euid;</span><br><span class="line">			...</span><br></pre></td></tr></table></figure>
<h2 id="查询selinux策略库进行selinux权限检查"><a href="#查询selinux策略库进行selinux权限检查" class="headerlink" title="查询selinux策略库进行selinux权限检查"></a>查询selinux策略库进行selinux权限检查</h2><p>addService和getService类似，以addService为例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// frameworks/native/cmds/servicemanager/ServiceManager.cpp</span><br><span class="line">Status ServiceManager::addService(const std::string&amp; name, const sp&lt;IBinder&gt;&amp; binder, ...) &#123;</span><br><span class="line">	// 获取对方的context，包括pid、selinux域、euid</span><br><span class="line">    auto ctx = mAccess-&gt;getCallingContext();</span><br><span class="line"></span><br><span class="line">    // apps cannot add services</span><br><span class="line">    if (multiuser_get_app_id(ctx.uid) &gt;= AID_APP) &#123;</span><br><span class="line">        return Status::fromExceptionCode(Status::EX_SECURITY);</span><br><span class="line">    &#125;</span><br><span class="line">	// canAdd 开始selinux权限检查</span><br><span class="line">    if (!mAccess-&gt;canAdd(ctx, name)) &#123;</span><br><span class="line">        return Status::fromExceptionCode(Status::EX_SECURITY);</span><br><span class="line">    &#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>canAdd再调用actionAllowedFromLookup</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">// frameworks/native/cmds/servicemanager/Access.cpp</span><br><span class="line">// 获取服务</span><br><span class="line">bool Access::canFind(const CallingContext&amp; ctx,const std::string&amp; name) &#123;</span><br><span class="line">    return actionAllowedFromLookup(ctx, name, &quot;find&quot;);</span><br><span class="line">&#125;</span><br><span class="line">// 注册服务</span><br><span class="line">bool Access::canAdd(const CallingContext&amp; ctx, const std::string&amp; name) &#123;</span><br><span class="line">    return actionAllowedFromLookup(ctx, name, &quot;add&quot;);</span><br><span class="line">&#125;</span><br><span class="line">// 列出服务列表</span><br><span class="line">bool Access::canList(const CallingContext&amp; ctx) &#123;</span><br><span class="line">    return actionAllowed(ctx, mThisProcessContext, &quot;list&quot;, &quot;service_manager&quot;);</span><br><span class="line">&#125;</span><br><span class="line">// 准备做权限检查</span><br><span class="line">bool Access::actionAllowedFromLookup(const CallingContext&amp; sctx, const std::string&amp; name, const char *perm) &#123;</span><br><span class="line">    char *tctx = nullptr;</span><br><span class="line">	// 查询手机中的service_contexts文件获取name对应的selinux标签</span><br><span class="line">	// name(android.security.keystore) -&gt; tctx（u:object_r:keystore_service:s0)</span><br><span class="line">    if (selabel_lookup(getSehandle(), &amp;tctx, name.c_str(), SELABEL_CTX_ANDROID_SERVICE) != 0) &#123;</span><br><span class="line">        LOG(ERROR) &lt;&lt; &quot;SELinux: No match for &quot; &lt;&lt; name &lt;&lt; &quot; in service_contexts.\n&quot;;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">	// 调用actionAllowed去做权限检查</span><br><span class="line">    bool allowed = actionAllowed(sctx, tctx, perm, name);</span><br><span class="line">    freecon(tctx);</span><br><span class="line">    return allowed;</span><br><span class="line">&#125;</span><br><span class="line">// 开始再做权限检查</span><br><span class="line">bool Access::actionAllowed(const CallingContext&amp; sctx, const char* tctx, const char* perm,</span><br><span class="line">        const std::string&amp; tname) &#123;</span><br><span class="line">	// 设置客体类型为service_manager</span><br><span class="line">    const char* tclass = &quot;service_manager&quot;;</span><br><span class="line">	// 填充audit回调数据，用于avc日志打印</span><br><span class="line">    AuditCallbackData data = &#123;</span><br><span class="line">        .context = &amp;sctx,</span><br><span class="line">        .tname = &amp;tname,</span><br><span class="line">    &#125;;</span><br><span class="line">	// 终于开始去查询selinux策略库了</span><br><span class="line">    return 0 == selinux_check_access(sctx.sid.c_str(), tctx, tclass, perm,</span><br><span class="line">        reinterpret_cast&lt;void*&gt;(&amp;data));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>selinux_check_access最终还是调用了avc_has_perm函数去做权限检查。在binder driver中调用的函数也叫avc_has_perm，只不过一个是用户态的实现，一个是内核态的实现。到这里，servicemanager的selinux权限逻辑就搞清楚。至于avc_has_perm这个函数，后面有时间的话在其他博客中写一下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">// external/selinux/libselinux/src/checkAccess.c</span><br><span class="line">int selinux_check_access(const char *scon, const char *tcon, const char *class, const char *perm, void *aux) &#123;</span><br><span class="line">	int rc;</span><br><span class="line">	security_id_t scon_id;</span><br><span class="line">	security_id_t tcon_id;</span><br><span class="line">	security_class_t sclass;</span><br><span class="line">	access_vector_t av;</span><br><span class="line"></span><br><span class="line">	__selinux_once(once, avc_init_once);</span><br><span class="line"></span><br><span class="line">	if (selinux_enabled != 1)</span><br><span class="line">		return 0;</span><br><span class="line">	// 主体(进程)selinux域转换成sid</span><br><span class="line">	rc = avc_context_to_sid(scon, &amp;scon_id);</span><br><span class="line">	if (rc &lt; 0)</span><br><span class="line">		return rc;</span><br><span class="line">	// 客体(file dir这种)selinux标签转换成sid</span><br><span class="line">	rc = avc_context_to_sid(tcon, &amp;tcon_id);</span><br><span class="line">	if (rc &lt; 0)</span><br><span class="line">		return rc;</span><br><span class="line"></span><br><span class="line">	(void) avc_netlink_check_nb();</span><br><span class="line">	// file 、dir、socket这种客体类型，这里是service_manager，goole自己扩展的</span><br><span class="line">       sclass = string_to_security_class(class);</span><br><span class="line">       if (sclass == 0) &#123;</span><br><span class="line">	       rc = errno;</span><br><span class="line">	       avc_log(SELINUX_ERROR, &quot;Unknown class %s&quot;, class);</span><br><span class="line">	       if (security_deny_unknown() == 0)</span><br><span class="line">		       return 0;</span><br><span class="line">	       errno = rc;</span><br><span class="line">	       return -1;</span><br><span class="line">       &#125;</span><br><span class="line">	// read、write这种权限，这里是add(addService)</span><br><span class="line">       av = string_to_av_perm(sclass, perm);</span><br><span class="line">       if (av == 0) &#123;</span><br><span class="line">	       rc = errno;</span><br><span class="line">	       avc_log(SELINUX_ERROR, &quot;Unknown permission %s for class %s&quot;, perm, class);</span><br><span class="line">	       if (security_deny_unknown() == 0)</span><br><span class="line">		       return 0;</span><br><span class="line">	       errno = rc;</span><br><span class="line">	       return -1;</span><br><span class="line">       &#125;</span><br><span class="line">		// 调用avc_has_perm判断是否有权限</span><br><span class="line">       return avc_has_perm (scon_id, tcon_id, sclass, av, NULL, aux);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/19/%E3%80%90ARM%E3%80%91adrp%E5%92%8Cadr%E6%8C%87%E4%BB%A4%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/19/%E3%80%90ARM%E3%80%91adrp%E5%92%8Cadr%E6%8C%87%E4%BB%A4%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">【ARM】adrp和adr指令详解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-04-19 22:43:14" itemprop="dateCreated datePublished" datetime="2022-04-19T22:43:14+08:00">2022-04-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-04-20 01:10:03" itemprop="dateModified" datetime="2022-04-20T01:10:03+08:00">2022-04-20</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>对adrp和adr这种PC相对寻址的指令一直只知道个大概，比如在取全局变量时经常就会用adrp指令，但是没有深入去了解，最好最近在看armv8的手册，就再梳理下。</p>
<h1 id="ADRP"><a href="#ADRP" class="headerlink" title="ADRP"></a>ADRP</h1><p>先看下armv8用户手册中对adrp指令的描述:</p>
<pre><code>Form PC-relative address to 4KB page adds an immediate value that is shifted left by 12 bits, to the PC value to form a PC-relative address, with the bottom 12 bits masked out, and writes the result to the destination register.

格式：ADRP &lt;Xd&gt;, &lt;label&gt;

&lt;Xd&gt; Is the 64-bit name of the general-purpose destination register, encoded in the &quot;Rd&quot; field.
&lt;label&gt; Is the program label whose 4KB page address is to be calculated. Its offset from the page address of this instruction, in the range +/-4GB, is encoded as &quot;immhi:immlo&quot; times 4096.
</code></pre>
<p>看到上面的这段英文，可能有点绕，没关系，继续往下看：</p>
<pre><code>adrp指令是32位的，指令编码：
31 30  29       23                     5 4       0
--------------------------------------------------
|  |immlo|      |          immhi        |   Rd   |
--------------------------------------------------

指令解码:
// 从低5位中解析目标寄存器的编号，5位编码可以表示32个
integer d = UInt(Rd);
// 从5-23位解析出immhi，从29-30位解析出immhi，加上低12位为0，得到一个32位的立即数
// 把得到的32位立即数扩充到64位，注意是有符号扩充，因为imm可能为负数
bits(64) imm = SignExtend(immhi:immlo:Zeros(12), 64);

伪码：
// 获取PC地址，在armv8上是64位，作为基址base
bits(64) base = PC[];
// 将base低12位置为0，求base所在4K页地址
base&lt;11:0&gt; = Zeros(12);
// base+imm的结果赋给目标寄存器
X[d] = base + imm;
</code></pre>
<p>对上面英文不理解的看到这里应该对adrp指令有点感悟了，所以看指令的描述不如直接看编码和实现，很简单，adrp就是获取当前的PC地址，低12位置0，然后加上一个imm立即数，将最终结果赋给目标寄存器。但是计算imm所用的immhi和immlo是怎么来的呢？adrp的作用又是啥呢？请看这么一段测试代码:</p>
<pre><code>// adrp.c
int a = 0;
int b = 0;

int main()
&#123;
    a = 1;
    return 0;
&#125;
</code></pre>
<p>编译和显示汇编:</p>
<pre><code>aarch64-linux-gnu-gcc adrp.c -o adrp
aarch64-linux-gnu-objdump -D adrp
</code></pre>
<p>main函数汇编如下，可以看到寻址全局变量b的时候就用到adrp指令：</p>
<pre><code>0000000000400570 &lt;main&gt;:
  400570:       b0000080        adrp    x0, 411000 &lt;_GLOBAL_OFFSET_TABLE_+0x28&gt;
  400574:       9100c000        add     x0, x0, #0x2c
  400578:       52800021        mov     w1, #0x1 
  40057c:       b9000001        str     w1, [x0]
  400580:       52800000        mov     w0, #0x0
  400584:       d65f03c0        ret

0000000000411028 &lt;__bss_start&gt;:
  411028:       00000000        .word   0x00000000
000000000041102c &lt;a&gt;:
  41102c:       00000000        .word   0x00000000
0000000000411030 &lt;b&gt;:
    ...
</code></pre>
<p>“adrp x0, 411000” 这条指令的十六进制机器码为b0000080，转成二进制编码就是:    </p>
<pre><code>1100 0000 0000 0000 0000 0000 1000 0000
</code></pre>
<p>根据指令二进制编码进行解码，可以解析出immhi、immlo、Rd</p>
<pre><code>Rd    = 0                    (0-4)     表示目的寄存器是X0
immhi = 0000 0000 0000 100   (5-23)    
immlo = 10                   (29-30)
imm = 0000 0000 0000 0001 0010 0000 0000 0000 = 0x12000
</code></pre>
<p>再根据伪码算最终赋给目标寄存器X0的值是多少</p>
<pre><code>bits(64) base = PC[]   // base = 0x400570
base&lt;11:0&gt; = Zeros(12) // base = 0x400000
X0 = base + imm;       // X0   = 0x412000
</code></pre>
<p>所以”adrp x0, 411000”执行完，X0 &#x3D; 0x412000，继续执行下一条指令”add x0, x0, #0x2c”：</p>
<pre><code>// 0x2c为a地址到所在4k页地址的offset
X0 = X0 + 0x2c = 0x41202c
</code></pre>
<p>诶～ 0x41202c不就是全局变量a的地址吗？就这样对a寻址成功了？是的，这就是adrp的作用！先根据PC+imm进行寻址，获得a所在的4K页地址，再结合add指令，加上offset得到a的最终地址。这就是PC相对寻址，imm就是个相对PC所在4K页地址的offset，可正可负。那反过来adrp指令编码中的immhi和immlo其实是在编译过程中计算出来的：</p>
<pre><code>1) 计算全局变量a所在4K页地址(a地址低12位置0)
2) 计算adrp指令地址所在4K页地址(低12位置0)
3) imm = a所在4K页地址 - adrp指令所在4K页地址
4) 从imm中拆出immlo和immhi，编码到adrp指令中
5) 将a地址到a所在4K页地址的offset编码到下一条add指令中
</code></pre>
<p>adrp寻址原理搞清楚了，接着看下结合add指令，寻址范围有多少：</p>
<pre><code>// 范围共8G，PC地址向前4G，向后4G
2的21次方(immhi和imm共21位) × 4K = -4G ~ +4G
</code></pre>
<h1 id="ADR"><a href="#ADR" class="headerlink" title="ADR"></a>ADR</h1><p>待分析</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/18/%E3%80%90Android%E3%80%91ProcessState%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E4%B8%AD%E7%9A%84%E5%8F%8C%E9%87%8D%E6%A3%80%E6%9F%A5%E9%94%81%E5%AE%9A%E5%86%99%E6%B3%95%E5%B9%B6%E4%B8%8D%E5%AE%89%E5%85%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/18/%E3%80%90Android%E3%80%91ProcessState%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E4%B8%AD%E7%9A%84%E5%8F%8C%E9%87%8D%E6%A3%80%E6%9F%A5%E9%94%81%E5%AE%9A%E5%86%99%E6%B3%95%E5%B9%B6%E4%B8%8D%E5%AE%89%E5%85%A8/" class="post-title-link" itemprop="url">【Android】ProcessState单例模式中的双重检查锁定写法并不安全</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-04-18 22:50:14" itemprop="dateCreated datePublished" datetime="2022-04-18T22:50:14+08:00">2022-04-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-04-19 22:49:56" itemprop="dateModified" datetime="2022-04-19T22:49:56+08:00">2022-04-19</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在看binder源码的时候，看到&#x2F;frameworks&#x2F;native&#x2F;libs&#x2F;binder&#x2F;ProcessState.cpp中有这么一笔修改，说双重检查锁定模式在多线程环境下并不安全：</p>
<pre><code>double checked locking pattern is not safe on SMP
Change-Id: Ie6dd564bdcd45647cb4d62ab259462e3db112576
</code></pre>
<p>修改前的代码本质上是使用双重检查锁定模式的写法，这个写法在单例模式中很常见：</p>
<pre><code>sp&lt;ProcessState&gt; ProcessState::self()
&#123;
    // 第一次检查：如果gprocess不为空，直接返回
    if (gProcess != NULL) &#123;
        return gProcess;
    &#125;
    // gProces为空，可能有多个线程同时执行new ProcessState
    // 所以加锁保证只有一个线程能去new ProcessState
    Mutex::Autolock _l(gProcessMutex);
    // 第二次检查：如果gprocess为空，就new ProcessState
    if (gProcess == NULL) &#123;
        gProcess = new ProcessState(&quot;/dev/binder&quot;);
    &#125;
    return gProcess;
&#125;
</code></pre>
<p>修改后的代码在函数开头就加锁，不管ProcessState对象有没有被创建，每个线程通过这个单例函数获取ProcessState对象时就得获取锁，这样效率肯定会变低，为什么要这么改呢？为什么以前双重检查锁定模式的写法不安全呢？</p>
<pre><code>sp&lt;ProcessState&gt; ProcessState::self()
&#123;
    // 函数开头就加锁，也能保证只有一个线程能去new ProcessState
    Mutex::Autolock _l(gProcessMutex);
    // 只有一次检查
    if (gProcess != NULL) &#123;
        return gProcess;
    &#125;
    gProcess = new ProcessState(&quot;/dev/binder&quot;);
    return gProcess;
&#125;
</code></pre>
<p>创建一个对象并不是原子操作，gProcess &#x3D; new ProcessState(“&#x2F;dev&#x2F;binder”)可以分为3步：</p>
<pre><code>1. 分配ProcessState对象所需内存
2. 初始化对象，比如成员变量fd = open(&quot;/dev/binder&quot;)
3. 将分配的内存地址赋值给gProcess
</code></pre>
<p>因为ARM架构是弱内存序，为了性能优化有时候CPU会做指令重排，正常代码执行顺序是1-&gt;2-&gt;3，但是可能被重排成1-&gt;3-&gt;2。这种重排也不会对单线程运行的结果产生啥影响，所以是有可能发生的。那我们再回过头来看ProcessState::self()函数以前的写法，多个线程同时调用该函数就可能会出现问题：</p>
<pre><code>---------------------------------------------------------------
初始:  gProcess = NULL
---------------------------------------------------------------
线程1: 负责创建对象，但是指令被重排成1-&gt;3-&gt;2，执行完1和3，2还没执行
      gProcess已被赋值却没有完成对象初始化
---------------------------------------------------------------
线程2: 开始获取gProcess，因为gProcess已被线程1赋值，所以获取成功，
      但是线程1还没有完成对象的初始化，线程2去访问gProcess就会出现问题
---------------------------------------------------------------
</code></pre>
<p>所以为了多线程环境下的安全性，只好在函数开头就加锁了，尽管会牺牲一定的效率。Android在开发者网站上也说明了这种场景，链接如下：</p>
<pre><code>https://developer.android.google.cn/training/articles/smp?hl=zh_cn
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/17/%E3%80%90Android%E3%80%91Refbase%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E5%BA%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/17/%E3%80%90Android%E3%80%91Refbase%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E5%BA%8F/" class="post-title-link" itemprop="url">【Android】Refbase对象引用计数操作中的内存序</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-04-17 10:54:16" itemprop="dateCreated datePublished" datetime="2022-04-17T10:54:16+08:00">2022-04-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-04-18 22:46:15" itemprop="dateModified" datetime="2022-04-18T22:46:15+08:00">2022-04-18</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在读Android智能指针sp、wp以及Refbase的源码时，发现对象强引用计数mstrong递增的时候使用memory_order_relaxed内存序，但是在递减的时候使用memory_order_release内存序，并且在递减为0时设置内存屏障atomic_thread_fence(memory_order_acquire)。强引用计数mstrong递增使用relaxed序好理解，只要保证原子性就可以，但是递减为什么不能用relaxed内存序，差异在哪？</p>
<pre><code>std::atomic&lt;int32_t&gt; mStong;

void RefBase::incStrong(const void* id) const
&#123;
    weakref_impl* const refs = mRefs;
    refs-&gt;incWeak(id);
    ...
    // 递增使用memory_order_relaxed内存序
    const int32_t c = refs-&gt;mStrong.fetch_add(1, std::memory_order_relaxed);
    if (c != INITIAL_STRONG_VALUE)  &#123;
        return;
    &#125;
    ...
&#125;
void RefBase::decStrong(const void* id) const
&#123;
    weakref_impl* const refs = mRefs;
    ...
    // 递减使用memory_order_release内存序
    const int32_t c = refs-&gt;mStrong.fetch_sub(1, std::memory_order_release);
    // c为递减之前的值，为1说明mstrong已经为0了
    if (c == 1) &#123;
        // 设置内存屏障
        std::atomic_thread_fence(std::memory_order_acquire);
        ...
        // delete对象
        delete this;
    &#125;
    ...
&#125;
</code></pre>
<p>在stack overflow中搜到这么个回答，其中有例子代码，但是感觉也没讲到本质，一直在纠结release-acquire ordering的表面意思，没有从指令重排的角度讲，看了半天还没理解：</p>
<pre><code>https://stackoverflow.com/questions/48124031/stdmemory-order-relaxed-atomicity-with-respect-to-the-same-atomic-variable/48148318#48148318
</code></pre>
<p>后面又去看了一些资料，mstrong递减使用memory_order_release内存序并且设置内存屏障, 就是为了保证：</p>
<pre><code>在多线程场景下，不管最后哪个线程(将mstrong递减为0的线程)负责delete对象，delete对象一定要发生在其他线程访问对象完成之后
</code></pre>
<p>memory_order_release作用是保证当前线程所有读写内存的指令不能重排到release后面，即所有线程访问对象发生在mstrong递减之前</p>
<pre><code>cppreference中的描述：A store operation with this memory order performs the release operation: no reads or writes in the current thread can be reordered after this store. All writes in the current thread are visible in other threads that acquire the same atomic variable (see Release-Acquire ordering below) and writes that carry a dependency into the atomic variable become visible in other threads that consume the same atomic (see Release-Consume ordering below). 
</code></pre>
<p>memory_order_acquire作用是保证表示当前线程读写内存的指令不能重排到acquire前面，在mstrong递减为0时，设置acquire的内存屏障，那么在最后将refcount递减为0的线程中，delete对象一定发生在递减为0之后</p>
<pre><code>cppreference中的描述：A load operation with this memory order performs the acquire operation on the affected memory location: no reads or writes in the current thread can be reordered before this load. All writes in other threads that release the same atomic variable are visible in the current thread (see Release-Acquire ordering below)
</code></pre>
<p>memory_order_release和memory_order_acquire配合起来用就可以达成上面所说的目的</p>
<p>请看下面例子：</p>
<p>有2个线程通过sp智能指针访问同一个对象obj，因为1.2是一定发生在2.2之前(递减为原子操作，肯定是先递减为1，再递减为0)，如果完全按照代码顺序，那么1.1必然发生在2.3之前，不会存在什么问题</p>
<pre class="mermaid">graph TB
A(thread-1)
B[1.1 通过sp指针访问对象obj]
C[1.2 obj引用计数递减为1]
D[线程退出]
E(thread-2)
F[2.1 通过sp指针访问对象obj]
G[2.2 obj引用计数递减为0]
H[2.3 delete obj]
I[线程退出]
A-->B-->C-->D
E-->F-->G-->H-->I</pre>

<p>但是ARM架构是弱内存序，cpu执行指令时为了做一些优化，可能会对指令进行重排，但是一定会保证单线程代码执行的正确性。比如将1.1重排到1.2之后，单独看thread-1，是不存在任何问题，因为thread-1递减mstrong之后不需要delete对象，完全不影响正确性。重排之后变成下面这样。虽然1.2还是一定发生在2.2之前，但是已经无法保证1.1发生在2.3之前了。那就有问题了</p>
<pre class="mermaid">graph TB
A(thread-1 重排后)
B[1.1 通过sp指针访问对象obj]
C[1.2 obj引用计数递减为1]
D[线程退出]
E(thread-2)
F[2.1 通过sp指针访问对象obj]
G[2.2 obj引用计数递减为0]
H[2.3 delete obj]
I[线程退出]
A-->C-->B-->D
E-->F-->G-->H-->I</pre>

<p>再看下cppreference中给的例子，和上面的其实是类似的：</p>
<pre><code>std::atomic&lt;std::string*&gt; ptr;
int data;

void producer()
&#123;
    std::string* p  = new std::string(&quot;Hello&quot;);
    data = 42;
    // 线程1将p赋值给ptr
    // 并且使用release保证data = 42不会重排在store之后
    // 其实重排并不会对线程1正确性产生影响)
    ptr.store(p, std::memory_order_release);
&#125;
void consumer()
&#123;
    std::string* p2;
    // 线程2循环读取ptr，判断ptr是否已经被线程1赋值
    // 并且使用acquire保证assert(data == 42)不会重排在load之后执行
    // 其实重排也不会对线程2正确性产生影响
    while (!(p2 = ptr.load(std::memory_order_acquire)))
    ;
    // 走到这里说明ptr已经被线程1赋值了，那么data肯定已经被线程1赋值为42了
    assert(*p2 == &quot;Hello&quot;); // 必然为真
    assert(data == 42); // 必然为真
&#125;
int main()
&#123;
    std::thread t1(producer);
    std::thread t2(consumer);
    t1.join(); t2.join();
&#125;
</code></pre>
<p>到这里问题基本上搞清楚了，memory_order_release和memory_order_acquire配合起来可以用来做线程间的同步。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">6</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  













<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

  

</body>
</html>
